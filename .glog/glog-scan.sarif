{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "29b13a5d-59a3-3bdc-bf3b-705753a4df6b",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn the InterSystems ObjectScript programming language, the `read` command is used to get input from the user. If the length of the input is not restricted or validated, it can lead to a vulnerability known as Unrestricted Read Length or Lack of Input Validation. This vulnerability can be exploited by an attacker to cause a Denial of Service (DoS) attack by providing very large input, which can lead to resource exhaustion.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input length limits and validation after the input is read. This can be done by checking the length of the input string and validating it against a predefined limit. If the input exceeds the limit, an error message should be displayed and the input should be discarded.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix for the vulnerability:\n\n```objectscript\nread !, \"Name: \", name\nif $length(name) > 50 {\n    write !, \"Error: Name is too long. Please enter a name with 50 characters or less.\"\n} else {\n    // Continue with the rest of the code\n}\n```\n\nIn this code, the length of the input `name` is checked after it is read. If the length exceeds 50 characters, an error message is displayed and the input is discarded.\n\nAdditionally, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies to execute properly.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are active and accessible to anonymous users."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "dde36b30-4084-3114-9c88-74272d0a459d",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn InterSystems ObjectScript, the `read` command is used to get input from the user. If the `read` command is used without any restrictions on the length of the input, it can lead to a vulnerability known as Unrestricted Read Length or Lack of Input Validation. This vulnerability can be exploited by an attacker to cause a Denial of Service (DoS) attack by providing a very large input, which can exhaust the system resources (memory/CPU).\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the length of the user input. This can be done by reading the input into a variable and then checking the length of the variable. If the length of the variable exceeds the maximum allowed length, the program should reject the input and ask the user to enter the input again.\n\n## Source Code Fix Recommendation\n\nHere is a sample code that demonstrates how to enforce input validation and limit the length of the user input:\n\n```objectscript\nread !, \"DOB: \", dob\nif $length(dob) > 10 {\n    write !, \"Input is too long. Please enter a valid DOB.\"\n} else {\n    // Continue with the program\n}\n```\n\nIn addition to the above code fix, it is also important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript.\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are active and accessible to anonymous users."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "cafcafb1-54e4-3005-a9fe-3fd052454113",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn InterSystems ObjectScript, the `read` command is used to get input from the user. If the `read` command is used without any restrictions on the length of the input, it can lead to a vulnerability known as Unrestricted Read Length or Lack of Input Validation. This vulnerability can be exploited by an attacker to cause a Denial of Service (DoS) attack by providing a very large input, which can lead to resource exhaustion.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the length of the input that can be read. This can be done by reading the input into a variable and then checking the length of the variable. If the length of the variable exceeds the maximum allowed length, the program should throw an error or discard the input.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix for the vulnerability:\n\n```objectscript\nread !, \"Phone: \", phone\nif $length(phone) > 15 {\n    write \"Phone number is too long. Please enter a valid phone number.\"\n    quit\n}\n```\n\nIn this code, the length of the phone number is checked after it is read. If the length is more than 15 characters, an error message is displayed and the program quits.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution for access control issues. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript.\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "435010c9-558e-3363-b9d6-0240e98604bb",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn InterSystems ObjectScript, the `read` command is used to get input from the user. If the length of the input is not restricted or validated, it can lead to a Denial of Service (DoS) attack where an attacker can supply very large input, causing the system to exhaust its resources (memory/CPU).\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input length limits and validation after the input is read. This can be done by checking the length of the input and rejecting it if it exceeds a certain limit. Additionally, the input should be validated to ensure it meets certain criteria (e.g., it does not contain malicious code).\n\n## Source Code Fix Recommendation\n\nHere is an example of how you can enforce input length limits and validation in ObjectScript:\n\n```objectscript\nread !, \"Name: \", name\nif $length(name) > 50 {\n    write !, \"Input is too long. Please enter a name that is 50 characters or less.\"\n} else if name['A' {\n    write !, \"Invalid input. Please enter a valid name.\"\n} else {\n    // Continue with the rest of the code\n}\n```\n\nIn this example, the input is rejected if it is longer than 50 characters or if it does not start with a letter. Adjust these checks as necessary to fit your specific requirements.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution for access control issues. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript. Additionally, environment safeguards and real logging/auditing should be implemented.\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "4e6b4276-0f0e-32cd-8208-0994f0e7ce53",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn InterSystems ObjectScript, the `read` command is used to get input from the user. If the `read` command is used without any restrictions on the length of the input, it can lead to a vulnerability known as Unrestricted Read Length or Lack of Input Validation. This vulnerability can be exploited by an attacker to cause a Denial of Service (DoS) attack by providing a very large input, which can exhaust the system resources (memory/CPU).\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the length of the user input. This can be done by reading the input into a variable and then checking the length of the variable. If the length of the variable exceeds the maximum allowed length, the program should reject the input and ask the user to enter the input again.\n\n## Source Code Fix Recommendation\n\nHere is a sample code that demonstrates how to enforce input validation and limit the length of the user input:\n\n```objectscript\nread !, \"DOB: \", dob\nif $length(dob) > 10 {\n    write !, \"Input is too long. Please enter a valid DOB.\"\n} else {\n    // Continue with the program\n}\n```\n\nIn addition to the above code fix, it is also important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript.\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are active and accessible to anonymous users."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "6c9216c5-1199-3e3d-be32-76444508b497",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn InterSystems ObjectScript, the `read` command is used to get input from the user. If the `read` command is used without any restrictions on the length of the input, it can lead to a vulnerability known as Unrestricted Read Length or Lack of Input Validation. This vulnerability can be exploited by an attacker to cause a Denial of Service (DoS) attack by providing a very large input, which can lead to resource exhaustion.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the length of the input that can be read. This can be done by reading the input into a variable and then checking the length of the variable. If the length of the variable exceeds the maximum allowed length, the program should throw an error or discard the input.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix for the vulnerability:\n\n```objectscript\nread !, \"Phone: \", phone\nif $length(phone) > 15 {\n    write \"Phone number is too long. Please enter a valid phone number.\"\n    quit\n}\n```\n\nIn this code, the length of the phone number is checked after it is read. If the length is more than 15 characters, an error message is displayed and the program quits.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution for access control issues. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript.\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "cd5c0c9e-441e-3ab5-ae94-990b4540352a",
              "name": "\"READ Vulnerability Due to Lack of Length Limit: Consider Implementing #maxlen for Enhanced Security\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn the InterSystems ObjectScript programming language, the `READ` command is used to get input from the user. However, if there is no limit set on the length of the input, it can lead to a vulnerability where an attacker can cause a Denial of Service (DoS) by providing a very large input. This can lead to resource exhaustion, consuming excessive memory and CPU resources.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input after it has been read. This can be done by checking the length of the input string and rejecting it if it exceeds a certain limit. Additionally, input validation should be performed to ensure that the input meets certain criteria.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```objectscript\ndo {\n    read !, \"Name: \", name\n    return:(name = \"\") 0  // user entered nothing so return FALSE, exit loop AND method\n    if $LENGTH(name) > 100 { // check if the length of the name exceeds 100 characters\n        write !, \"Name is too long. Please enter a name with 100 characters or less.\"\n        continue\n    }\n} while '..ValidName(name)\n```\n\nIn this fix, the length of the input `name` is checked after it is read. If the length exceeds 100 characters, a message is displayed to the user and the loop continues to the next iteration.\n\nNote: In addition to the above source code fix, it is also important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This can be done using the `$SYSTEM.Security.Check()` method in ObjectScript.\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## OWASP and CWE Resources\n\n- [OWASP - Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the above links are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "3ed646f7-709c-3f10-a7ac-befa9871452f",
              "name": "\"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\" in ObjectScript programming language refers to the potential for an attacker to cause a denial of service (DoS) attack by supplying very large input to the `READ` command. This can lead to resource exhaustion, consuming excessive memory or CPU resources. \n\nIn the provided code snippet, the `READ` command is used to accept user input without any limit on the length of the input. This makes the application susceptible to DoS attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input that can be accepted by the `READ` command. This can be done by checking the length of the input after it has been read and before it is processed further. If the length of the input exceeds the defined limit, the input should be rejected and an appropriate error message should be displayed to the user.\n\nAdditionally, it is important to validate the input downstream to ensure that it meets the expected format and does not contain any malicious data. This can be done using regular expressions or built-in validation functions.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\ndo {\n    read !, \"DOB: \", dob\n    if $LENGTH(dob) > maxLength {\n        write !, \"Input is too long. Please enter a DOB of length less than \", maxLength\n    } elseif '..ValidDOB(dob, .intdob) {\n        // process the input\n    } else {\n        write !, \"Invalid DOB. Please enter a valid DOB.\"\n    }\n} while 1\n```\n\nIn this code, `maxLength` is a predefined constant that specifies the maximum allowed length of the input.\n\nNote: Besides the proposed solution in the source code, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This can be achieved using `$SYSTEM.Security.Check()` for resource/privilege check, along with environment safeguards and real logging/auditing.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## References\n\n- [CWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion')](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "499a80f3-9d51-308a-a8b7-d54e1e77d26a",
              "name": "\"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\" in ObjectScript programming language refers to the potential for an attacker to cause a denial of service (DoS) attack by supplying very large input. This can lead to resource exhaustion, consuming significant memory and CPU resources. \n\nIn the provided code snippet, the `read` command is used without a length limit, which means it can accept an unlimited amount of input. This can be exploited by an attacker to cause a DoS attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input that can be accepted. This can be done by using the `#` syntax in the `read` command to specify a maximum number of characters. However, it's important to note that in ObjectScript, the `#` syntax means read exactly \"number\" characters, not “up to number”. Any extra characters the user typed can remain in the input buffer and be consumed by subsequent `read` commands, which can cause confusing behavior. \n\nTherefore, the best mitigation strategy is to keep the normal line `read`, then enforce limits and validation downstream. This can be done by checking the length of the input and rejecting it if it exceeds a certain limit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\ndo {\n    read !, \"DOB: \", dob\n    if $LENGTH(dob) > maxLength {\n        write !, \"Input is too long. Please enter a DOB of \", maxLength, \" characters or less.\"\n    }\n} While '..ValidDOB(dob, .intdob) && ($LENGTH(dob) <= maxLength)\n```\n\nIn this code, `maxLength` is a variable that you should define elsewhere in your code to be the maximum acceptable length of the input.\n\nAdditionally, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This can be done using `$SYSTEM.Security.Check()` for resource/privilege check in ObjectScript, along with environment safeguards and real logging/auditing.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP Top 10 - A3:2017-Sensitive Data Exposure](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that these links are subject to change and may not be accessible to all users."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "42493282-59f2-325f-a414-89b76af33cf1",
              "name": "\"READ Function Vulnerability: Lack of Length Limit and Need for #maxlen Implementation\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `READ` function in the ObjectScript programming language. The `READ` function is used to read input from the user. In the provided code snippet, there is no limit on the length of the input that can be provided by the user. This can lead to resource exhaustion or denial of service (DoS) attacks if an attacker provides a very large input. \n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input that can be read. This can be done by checking the length of the input after it has been read and before it is processed further. If the length of the input exceeds the limit, the input should be rejected and an appropriate error message should be displayed to the user. \n\nIn addition to this, it is also recommended to implement proper validation checks on the input to ensure that it is in the expected format and does not contain any malicious data. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\ndo {\n    read !, \"Name: \", name\n    if $LENGTH(name) > 100 { // limit input length to 100 characters\n        write !, \"Error: Name is too long. Please enter a name with 100 characters or less.\"\n        continue\n    }\n    return:(name = \"\") 0  // user entered nothing so return FALSE, exit loop AND method\n} While '..ValidName(name)\n```\n\nIn this fix, the length of the input is checked after it is read. If the length of the input exceeds 100 characters, an error message is displayed and the loop continues to the next iteration.\n\nNote: This code fix is a part of the solution. Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. \n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP Top 10 - A1 Injection](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "54211a2f-95e9-3e07-897e-253a1bd9dc64",
              "name": "\"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\" in ObjectScript programming language refers to the potential for an attacker to cause a denial of service (DoS) attack by supplying very large input to the `READ` command. This can lead to resource exhaustion, consuming excessive memory and CPU resources. \n\nIn the provided code example, the `READ` command is used to accept user input without any limit on the length of the input. This makes the application susceptible to DoS attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input that can be accepted by the `READ` command. This can be done by checking the length of the input after it has been read and before it is processed further. If the length of the input exceeds the defined limit, the input should be rejected and an appropriate error message should be displayed to the user.\n\nAdditionally, it is important to validate the input downstream to ensure that it meets the required format and does not contain any malicious data. This can be done using regular expressions or other input validation techniques.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code example:\n\n```objectscript\ndo {\n    read !, \"Phone (617): \", phone\n    if $LENGTH(phone) > 10 {\n        write !, \"Input too long. Please enter a valid phone number.\"\n    } elseif '..ValidPhone(.phone) {\n        // process the phone number\n    } else {\n        write !, \"Invalid phone number. Please try again.\"\n    }\n} While $LENGTH(phone) > 10 || '..ValidPhone(.phone)\n```\n\nIn this fix, the length of the input is checked immediately after it is read. If the length exceeds 10 characters, an error message is displayed and the user is prompted to enter the input again. The input is also validated using the `ValidPhone` function.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This can be done using `$SYSTEM.Security.Check()` in addition to the above code fix.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "5ec0f754-a889-33c5-965e-aa50f1b6348e",
              "name": "Potential race condition in uniqueness check with separate SET method: consider using LOCK for validate-store operation.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe code snippet provided is vulnerable to a race condition during the check for uniqueness of a phone number in the `^PersonI(\"Phone\", phone)` global. A race condition occurs when the behavior of a system depends on the relative timing of events, such as the order in which threads are scheduled. In this case, the race condition can occur if another process inserts the same phone number into the `^PersonI(\"Phone\", phone)` global between the time this process checks for the phone number's existence and the time it inserts the phone number.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use a lock to ensure that only one process can check for the phone number's existence and insert the phone number at a time. This will prevent other processes from inserting the same phone number between the time this process checks for the phone number's existence and the time it inserts the phone number.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code snippet:\n\n```objectscript\nlock +^PersonI(\"Phone\", phone):0\nif $data(^PersonI(\"Phone\", phone)) {\n    write !, \"Phone number already in use\"\n    lock -^PersonI(\"Phone\", phone)\n    return 0\n}\n// insert phone number into ^PersonI(\"Phone\", phone) global here\nlock -^PersonI(\"Phone\", phone)\n```\n\nIn this fix, the `lock +^PersonI(\"Phone\", phone):0` command acquires a lock on the `^PersonI(\"Phone\", phone)` global. The `lock -^PersonI(\"Phone\", phone)` command releases the lock. This ensures that only one process can check for the phone number's existence and insert the phone number at a time.\n\nNote: Beside proposed solution in the source code, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be primary solution. This can be achieved by using `$SYSTEM.Security.Check()` for resource/privilege check plus environment safeguards and real logging/auditing.\n\n## Library Dependencies\n\nThe code snippet does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-362"
                ]
              }
            },
            {
              "id": "bf4b8989-114a-35f2-b7a6-e46ab8b15089",
              "name": "Consider using TSTART/TCOMMIT for consistency when multiple related SETs follow $INCREMENT outside transaction.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn InterSystems ObjectScript, the `$increment` function is used to atomically increment a global or local variable. However, when multiple related `SET` operations follow `$increment` outside a transaction, it can lead to inconsistencies. This is because `$increment` is atomic, but the subsequent `SET` operations are not. If an error occurs during one of the `SET` operations, or if another process modifies the data between the `SET` operations, the data can become inconsistent.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use `TSTART` and `TCOMMIT` to wrap the `$increment` and related `SET` operations in a transaction. This ensures that all operations within the transaction are treated as a single atomic operation, which either completely succeeds or completely fails. This prevents inconsistencies from occurring.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```objectscript\nTSTART\nset id = $increment(^PersonD)  // use $increment to generate a new ID\n// ... other related SET operations ...\nTCOMMIT\n```\n\nIn addition to the source code fix, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This can be achieved by using `$SYSTEM.Security.Check()` to check user roles for authorization, along with environment safeguards and real logging/auditing.\n\n## Library Dependencies\n\nThe provided code does not require any library dependencies to execute properly.\n\n## References\n\n- [OWASP - Insecure Direct Object References](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-362"
                ]
              }
            },
            {
              "id": "472c15e6-ffcc-3a94-8295-65e61fb52e2d",
              "name": "\"Data Reset Pattern Vulnerability\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Data Reset Pattern Vulnerability\" in ObjectScript is a type of vulnerability that occurs when an application does not properly manage the data in global variables. In the provided code example, the `kill` command is used to delete all data in the `^PersonD` and `^PersonI` global variables. If an attacker can trigger this method, they can cause a denial of service by deleting all the data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should ensure that only authorized users can trigger methods that modify global variables. This can be achieved by implementing proper access control mechanisms in your application. Additionally, you should consider using transactions to ensure that data modifications are atomic and can be rolled back in case of errors.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code example:\n\n```objectscript\nClassMethod Load() As %Status\n{\n    // Check if the current user has the necessary privileges\n    if '$SYSTEM.Security.Check(\"DataResetPrivilege\", \"%Admin_Manage\") {\n        return $$$ERROR($$$Unauthorized)\n    }\n\n    // Delete the data\n    kill ^PersonD, ^PersonI\n\n    return $$$OK\n}\n```\n\nIn this fix, the `$SYSTEM.Security.Check()` method is used to check if the current user has the necessary privileges to reset the data. If the user does not have the necessary privileges, the method returns an error. This ensures that only authorized users can trigger the data reset.\n\nNote: This source code fix is a secondary measure. The primary solution should be enforcing authorization using IRIS security (resources/roles) and/or application authentication.\n\n## References\n\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "b7d2889e-cb47-33e2-86e2-13bf33b98386",
              "name": "\"Unprotected Transaction Block Vulnerability with Error Handling via Try/Catch and TROLLBACK\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the lack of error handling in the transaction block. In the provided ObjectScript code, the transaction block is started with `tstart` and committed with `tcommit` without any error handling mechanism. If an error occurs during the transaction, the changes are not rolled back, which can lead to data inconsistency or corruption.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a `try/catch` block to handle any exceptions that may occur during the transaction. If an exception is caught, the transaction should be rolled back using `trollback`. This ensures that if an error occurs, the changes made in the transaction are not committed, preventing data inconsistency or corruption.\n\n## Source Code Fix Recommendation\n\nHere is the recommended fix for the provided code:\n\n```objectscript\ntstart\ntry {\n  set ^PersonD(id) = answers  // store the answers\n\n  set $listbuild(name, phone, intdob) = answers\n  // split name into last and first for storage in index\n  set last = $piece(name, \",\", 1), first = $piece(name, \",\", 2)\n\n  /* the next three statements store data in subscripts.\n  because of the automatic sorting of subscripts,\n  this has the effect of building 3 indices: name, phone, and DOB */\n  set ^PersonI(\"Name\", last, first, id) = \"\"  // index last and first name\n  set ^PersonI(\"Phone\", phone) = id           // index the UNIQUE phone\n  set ^PersonI(\"DOB\", intdob, id) = \"\"        // index the internal DOB\n\n  /* these statements turn the id into a \"chunk #\" and a \"position #\"\n  and set a bit into the bitmap index */\n  set chunk = (id\\64000) + 1, position = (id#64000) + 1\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 1\n  tcommit\n} catch {\n  trollback\n  // handle the exception, e.g., log the error, notify the user, etc.\n}\n```\n\nThis code wraps the transaction in a `try/catch` block. If an error occurs during the transaction, the `catch` block is executed, which rolls back the transaction and can handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP Error Handling](https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html)\n- [CWE-391: Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This can be achieved by checking user roles for authorization using `$SYSTEM.Security.Check()` in ObjectScript, in addition to the proposed source code fix."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-391",
                    "url": "https://cwe.mitre.org/data/definitions/391.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-391"
                ]
              }
            },
            {
              "id": "01879d89-0731-3f2d-8f28-222b8397169c",
              "name": "\"Global Root Deletion: Admin-Only Access, Not for Production Use\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"Global Root Deletion: Admin-Only Access, Not for Production Use\" in ObjectScript programming language refers to the situation where an application allows deletion of global root nodes in the database. This operation is highly sensitive and should only be performed by administrators. If not properly protected, it can lead to unauthorized data manipulation or deletion, leading to data loss or corruption.\n\nIn the provided code example, the `kill` command is used to delete the `^PersonD` and `^PersonI` global root nodes:\n\n```objectscript\nkill ^PersonD, ^PersonI\n```\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to enforce strict access control measures. Only users with the necessary privileges should be allowed to perform such operations. This can be achieved by implementing proper role-based access control (RBAC) and ensuring that only users with the 'Admin' role can execute the `kill` command.\n\n## Source Code Fix Recommendation\n\nThe source code can be fixed by checking the user's role before executing the `kill` command. This can be done using the `$SYSTEM.Security.Check()` method. Here is an example:\n\n```objectscript\nif $SYSTEM.Security.Check(\"Admin\", \"%Admin_Manage\") {\n    kill ^PersonD, ^PersonI\n} else {\n    write \"Insufficient privileges to perform this operation.\"\n}\n```\n\nIn this code, the `kill` command will only be executed if the user has the 'Admin' role. If not, an error message will be displayed.\n\n**Note:** This source code fix is a secondary measure. The primary solution should be enforcing authorization using IRIS security (resources/roles) and/or application authentication.\n\n## Library Dependencies\n\nThe provided code example does not require any additional library dependencies to execute properly.\n\n## References\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that the provided links are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "4d0c456f-a42e-311e-b69e-14311e702bb7",
              "name": "\"Admin-Only Restriction Required for Detected Extent Deletion Vulnerability\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"Admin-Only Restriction Required for Detected Extent Deletion Vulnerability\" in ObjectScript programming language refers to a situation where an unauthorized user can delete an entire extent of data. This can occur when the `%KillExtent()` method is used without proper access control checks. This method deletes all instances of a class stored in the database, which can lead to data loss if exploited by malicious users.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper access control checks before executing the `%KillExtent()` method. This can be achieved by checking the user's role and ensuring that only users with administrative privileges can execute this method. \n\nIn addition to the source code fix, it is also recommended to enforce authorization using IRIS security (resources/roles) and/or application authentication. This should be the primary solution to prevent unauthorized access and potential data loss.\n\n## Source Code Fix Recommendation\n\nHere is a sample code snippet that checks if the current user has the 'Admin' role before executing the `%KillExtent()` method:\n\n```objectscript\nset isAdmin = $SYSTEM.Security.Check(\"Admin\",,1)\nif isAdmin {\n    do ##class(ObjectScript.Person).%KillExtent()\n} else {\n    write \"You do not have the necessary permissions to perform this action.\"\n}\n```\n\nIn this code, `$SYSTEM.Security.Check(\"Admin\",,1)` checks if the current user has the 'Admin' role. If the user has the 'Admin' role, the `%KillExtent()` method is executed. Otherwise, an error message is displayed.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Resources\n\n- [OWASP Access Control Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that these links are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "e4b58409-487c-3a5f-93f3-358dcf66133a",
              "name": "\"READ Validation Lacks Length Limit Despite Match/Pattern Verification\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"READ Validation Lacks Length Limit Despite Match/Pattern Verification\" in ObjectScript programming language refers to the situation where the `READ` command is used without a specified length limit. This can potentially lead to resource exhaustion or denial of service (DoS) attacks if an attacker is able to supply a very large input. This is particularly concerning in network-exposed UIs or APIs. \n\nIn the provided code snippet, the `READ` command is used to get user input without any length limit. Although there is a regular expression check (`$match`) to validate the format of the input, it does not prevent the user from entering a very large input.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input after the `READ` command. This can be done by checking the length of the input string and returning an error if it exceeds the maximum allowed length. \n\nAdditionally, it is important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This can help prevent unauthorized access and potential exploitation of this vulnerability.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nread !, \"Lookup: \", lookup\nreturn:(lookup = \"\") 0  // user entered nothing so return FALSE\nif $length(lookup) > 12 { // check if input length exceeds maximum allowed length\n  write \"Error: Input too long\",!\n  quit\n}\nif (lookup = \"?\") {\n  set type = \"help\", search = \"\"\n}\n// the RegEx accepts ###- or ###-###-#### only\nelseif $match(lookup, \"\\d{3}-(\\d{3}-\\d{4})?\") {\n  // ...\n}\n```\n\nIn this fix, the `$length` function is used to check the length of the input string. If it exceeds 12 characters (the maximum length for the accepted formats), an error message is displayed and the program quits.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## References\n\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "1f4724ef-1c72-3b83-aac4-2e58ac0c7a18",
              "name": "\"READ Validation Lacks Length Limit Despite Match/Pattern Verification\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"READ Validation Lacks Length Limit Despite Match/Pattern Verification\" in ObjectScript programming language refers to the situation where the `READ` command is used without a specified length limit. This can potentially lead to resource exhaustion or denial of service (DoS) attacks if an attacker is able to supply a very large input. This is particularly concerning in network-exposed UIs or APIs. \n\nIn the provided code snippet, the `READ` command is used to get user input without any length limit. Although there is a regular expression check (`$match`) to validate the format of the input, it does not prevent the user from entering a very large input.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input after the `READ` command. This can be done by checking the length of the input string and returning an error if it exceeds the maximum allowed length. \n\nAdditionally, it is important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This can help prevent unauthorized access and potential exploitation of this vulnerability.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nread !, \"Lookup: \", lookup\nreturn:(lookup = \"\") 0  // user entered nothing so return FALSE\nif $length(lookup) > 12 { // check if input length exceeds maximum allowed length\n  write \"Error: Input too long\",!\n  quit\n}\nif (lookup = \"?\") {\n  set type = \"help\", search = \"\"\n}\n// the RegEx accepts ###- or ###-###-#### only\nelseif $match(lookup, \"\\d{3}-(\\d{3}-\\d{4})?\") {\n  // ...\n}\n```\n\nIn this fix, the `$length` function is used to check the length of the input string. If it exceeds 12 characters (the maximum length for the accepted formats), an error message is displayed and the program quits.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## References\n\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "29ee34b7-ccf0-30dd-b66b-6f7bc6735d1b",
              "name": "\"Unprotected Transaction Block Vulnerability with Error Handling via Try/Catch and TROLLBACK\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the improper handling of transactions in InterSystems ObjectScript. The code block is not protected by error handling mechanisms, which can lead to inconsistencies in the database if an error occurs during the transaction. This can lead to data loss or corruption, and can potentially be exploited by an attacker to cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use the `try/catch` mechanism to handle any errors that may occur during the transaction. This will ensure that the transaction is rolled back in case of an error, preventing any inconsistencies in the database. Additionally, it is important to validate all inputs to prevent injection attacks.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability:\n\n```objectscript\ntry {\n  tstart\n  kill ^PersonD(id)\n  kill ^PersonI(\"Name\", last, first, id)\n  kill ^PersonI(\"Phone\", phone)\n  kill ^PersonI(\"DOB\", intdob, id)\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 0\n  tcommit\n} catch {\n  trollback\n  // handle error\n}\n```\n\nIn addition to the above, it is also recommended to enforce authorization using IRIS security (resources/roles) and/or application authentication. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript.\n\n## Library Dependencies\n\nThe code example does not appear to require any external library dependencies to execute properly.\n\n## References\n\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/)\n- [CWE-459: Incomplete Cleanup](https://cwe.mitre.org/data/definitions/459.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-459",
                    "url": "https://cwe.mitre.org/data/definitions/459.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-459"
                ]
              }
            },
            {
              "id": "72d80781-e079-3971-b3e2-6b71b145a3f1",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the deletion of a global node in the ObjectScript programming language without proper authorization verification and referential/index consistency maintenance. In the provided code snippet, `kill ^PersonD(id)`, a global node is being deleted without any checks for user authorization or referential integrity. This could potentially allow unauthorized users to delete data, leading to data loss or corruption.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before allowing a user to delete a global node. This can be achieved by using the `$SYSTEM.Security.Check()` method to verify if the user has the necessary privileges to perform the operation. Additionally, maintaining referential integrity is also important to prevent data corruption. This can be done by checking if the node to be deleted is not being referenced by any other nodes before proceeding with the deletion.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nset resourceId = \"%%ResourceName\"\nset userHasPrivilege = $SYSTEM.Security.Check(resourceId, \"%Delete\")\n\nif userHasPrivilege {\n    // Check for referential integrity before deletion\n    if '$data(^PersonD(id)) {\n        write \"Error: Node does not exist or is being referenced by another node.\",!\n    } else {\n        kill ^PersonD(id)\n    }\n} else {\n    write \"Error: User does not have the necessary privileges to delete this node.\",!\n}\n```\n\nIn this code, we first check if the user has the necessary privileges to delete a node by using the `$SYSTEM.Security.Check()` method. If the user has the necessary privileges, we then check for referential integrity before proceeding with the deletion. If the node does not exist or is being referenced by another node, we display an error message and abort the operation.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This source code fix is a secondary measure to ensure data integrity and security.\n\n## References\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "20132af7-7e3c-31be-bd4f-af6dee00c8e0",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the deletion of a global node in the ObjectScript programming language. The specific vulnerability sink is `kill ^PersonI(\"Name\", last, first, id)`. This command deletes a global node from the database without any authorization verification or referential/index consistency maintenance. This could potentially allow unauthorized users to delete data, leading to data loss or corruption.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement authorization checks before performing any deletion operation. This ensures that only authorized users can delete data. Additionally, maintaining referential and index consistency is important to prevent data corruption. This can be achieved by implementing checks to ensure that no other data depends on the data being deleted, or by updating all references to the deleted data.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix that includes an authorization check and referential/index consistency maintenance:\n\n```objectscript\nset authorized = $SYSTEM.Security.Check(\"Delete Person\", \"%DB_USER\")\nif 'authorized {\n    write \"You do not have permission to delete this data.\",!\n    quit\n}\nset refCheck = $data(^PersonI(\"Name\", last, first, id))\nif 'refCheck {\n    write \"Cannot delete data as it is referenced elsewhere.\",!\n    quit\n}\nkill ^PersonI(\"Name\", last, first, id)\n```\n\nIn this code, `$SYSTEM.Security.Check()` is used to check if the current user has the \"Delete Person\" permission. If not, the deletion operation is not performed. The `$data()` function is used to check if the data being deleted is referenced elsewhere. If it is, the deletion operation is not performed.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This source code fix is a secondary measure to ensure data security.\n\n## References\n\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "80e5bcc0-bd1f-325f-881b-f661c4d44193",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the deletion of a global node in the ObjectScript programming language without proper authorization verification and referential/index consistency maintenance. In the provided code snippet, a global node `^PersonI(\"Phone\", phone)` is being deleted without any checks for user authorization or referential integrity. This could potentially allow unauthorized users to delete data, leading to data loss or corruption.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before allowing any user to delete a global node. This can be achieved by using the `$SYSTEM.Security.Check()` method to verify if the user has the necessary privileges to perform the deletion operation. \n\nAdditionally, it is also important to maintain referential/index consistency when deleting a global node. This can be done by checking if the node to be deleted is referenced elsewhere in the application and updating or deleting those references as necessary.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nset phone = \"1234567890\"\nset resource = \"%%ResourceName%%\"\nset access = \"RW\"\nset result = $SYSTEM.Security.Check(resource, access)\nif 'result {\n    write \"User does not have the necessary privileges to delete this node.\",!\n    quit\n}\n// Perform referential/index consistency checks here\nkill ^PersonI(\"Phone\", phone)\n```\n\nIn this code, `$SYSTEM.Security.Check()` is used to check if the user has the necessary privileges to delete the node. If the user does not have the necessary privileges, an error message is displayed and the operation is aborted. \n\nPlease note that in addition to the source code fix, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. \n\n## Library Dependencies\n\nThe provided code snippet does not require any additional library dependencies to execute properly.\n\n## References\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that the links provided are active and accessible to anonymous users."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "1c63cc4b-0cc5-3298-8eb0-523a47135950",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the deletion of a global node in the ObjectScript programming language without proper authorization verification and referential/index consistency maintenance. In the provided code snippet, a global node `^PersonI(\"DOB\", intdob, id)` is being deleted without any checks for user authorization or referential integrity. This could potentially allow unauthorized users to delete critical data, leading to data loss or corruption.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before performing any deletion operation. This can be achieved by using the `$SYSTEM.Security.Check()` method provided by InterSystems ObjectScript. This method checks if the current user has the necessary privileges to perform the operation.\n\nIn addition to authorization checks, it is also important to maintain referential/index consistency when deleting global nodes. This can be done by checking if the node to be deleted is referenced by any other nodes and updating or deleting those references as necessary.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nset resource = \"%%resource%%\" // replace with actual resource\nset permission = \"W\" // write permission\nset status = $SYSTEM.Security.Check(resource, permission)\nif 'status {\n    write \"You do not have the necessary permissions to perform this operation.\",!\n    quit\n}\n\n// Check for referential integrity before deletion\n// ...\n\nkill ^PersonI(\"DOB\", intdob, id)\n```\n\nIn this fix, the `$SYSTEM.Security.Check()` method is used to check if the current user has write permission for the resource. If the user does not have the necessary permissions, the operation is aborted and a message is displayed to the user.\n\nPlease note that this code fix should be supplemented with proper IRIS security enforcement (resources/roles) and/or application authentication. Also, it is recommended to have real logging/auditing in place to track all operations.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP Authorization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\nPlease note that the provided links are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "1796d0d6-cb26-353c-bf29-b10f6a8320b8",
              "name": "\"Vulnerability of Unhandled Errors in Transaction Block without Rollback Mechanism\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability of \"Unhandled Errors in Transaction Block without Rollback Mechanism\" in ObjectScript programming language refers to the situation where an error occurs within a transaction block, but there is no mechanism in place to handle the error and rollback the transaction. This can lead to data inconsistency and corruption, as some operations within the transaction block may have been executed while others have not.\n\nIn the provided code, the transaction starts with `tstart` and ends with `tcommit`. If an error occurs in any of the operations within this block, there is no error handling or rollback mechanism in place. This means that some operations may have been executed and others not, leading to data inconsistency.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to implement error handling within the transaction block. This can be done by using the `try/catch` block to catch any errors that occur during the execution of the transaction. If an error is caught, the transaction should be rolled back using `trollback`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```objectscript\ntstart\ntry {\n  set ^PersonD(id) = newanswers\n  if (newname '= currentname) {\n    // kill old name and add new name to index\n    kill ^PersonI(\"Name\", currentlast, currentfirst, id)\n    set ^PersonI(\"Name\", newlast, newfirst, id) = \"\"\n  }\n  if (newphone '= currentphone) {\n    // kill old phone and add new phone to index\n    kill ^PersonI(\"Phone\", currentphone)\n    set ^PersonI(\"Phone\", newphone) = id\n  }\n  if (newintdob '= currentintdob) {\n    // kill old dob and add new dob to index\n    kill ^PersonI(\"DOB\", currentintdob, id)\n    set ^PersonI(\"DOB\", newintdob, id) = \"\"\n  }\n  tcommit  // commit the transaction\n} catch {\n  trollback  // rollback the transaction in case of an error\n}\n```\n\nIn addition to the above, it is also recommended to enforce authorization using IRIS security (resources/roles) and/or application authentication.\n\n## Library Dependencies\n\nThe provided code does not appear to have any library dependencies.\n\n## References\n\n- [CWE-391: Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-391",
                    "url": "https://cwe.mitre.org/data/definitions/391.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-391"
                ]
              }
            },
            {
              "id": "8ce05a7d-fb70-3819-9558-f376f862e78e",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the lack of proper authorization verification and referential/index consistency maintenance when deleting a global node in the ObjectScript programming language. In the provided code snippet, the `kill` command is used to delete a `PersonI` node from the global array, identified by `Name`, `currentlast`, `currentfirst`, and `id`. If an attacker gains access to this functionality, they could potentially delete arbitrary data, leading to data loss or corruption.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before allowing a user to delete a global node. This can be achieved by using the `$SYSTEM.Security.Check()` function to verify if the current user has the necessary privileges to perform the operation. Additionally, it is important to maintain referential/index consistency when deleting a node. This can be done by ensuring that all references to the node are also deleted or updated accordingly.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nset resource = \"%%resource.PersonI.Delete\"\nset status = $SYSTEM.Security.Check(resource, \"%USE\")\nif 'status {\n    write \"You do not have the necessary privileges to perform this operation.\",!\n    quit\n}\n\n// Check if the node exists before deleting\nif $data(^PersonI(\"Name\", currentlast, currentfirst, id)) {\n    kill ^PersonI(\"Name\", currentlast, currentfirst, id)\n} else {\n    write \"The specified node does not exist.\",!\n}\n```\n\nIn this fix, the `$SYSTEM.Security.Check()` function is used to verify if the current user has the `%USE` privilege for the `PersonI.Delete` resource. If the user does not have the necessary privilege, the operation is aborted. Additionally, the `$data` function is used to check if the node exists before attempting to delete it.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This source code fix is a secondary measure to enhance security.\n\n## References\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "5a8eaf42-0bfb-34db-9b94-e596fca1725d",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the deletion of a global node in the ObjectScript programming language without proper authorization verification and referential/index consistency maintenance. In the provided code snippet, a global node `^PersonI(\"Phone\", currentphone)` is being deleted without any checks for user authorization or referential integrity. This could potentially lead to unauthorized data deletion and inconsistencies in the database.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before performing any deletion operation. This can be achieved by using the `$SYSTEM.Security.Check()` method to verify if the current user has the necessary privileges to perform the operation. \n\nAdditionally, it is also important to maintain referential integrity when deleting a global node. This can be done by checking if the node is being referenced elsewhere before deleting it. If it is, the references should be updated or deleted as necessary to maintain consistency.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nset resource = \"PersonI\"\nset permission = \"W\"\n\nif '$SYSTEM.Security.Check(resource, permission) {\n    write \"User does not have the necessary permissions to delete this node.\",!\n    quit\n}\n\nif $data(^PersonI(\"Phone\", currentphone)) {\n    // Perform referential integrity checks here\n    // If checks pass, delete the node\n    kill ^PersonI(\"Phone\", currentphone)\n} else {\n    write \"Node does not exist.\",!\n}\n```\n\nIn this code, we first check if the user has the necessary permissions to delete the node. If they do not, we output an error message and exit. If they do, we check if the node exists. If it does, we perform referential integrity checks (not shown) and delete the node if the checks pass.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This source code fix is a secondary measure to ensure security at the code level.\n\n## References\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "33f20dda-eb54-3410-96f5-2d82070864bf",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the lack of proper authorization verification and referential/index consistency maintenance when performing a global node deletion operation in the ObjectScript programming language. In the provided code snippet, the `kill` command is used to delete a global node from the `^PersonI(\"DOB\", currentintdob, id)` global array. However, there is no verification to ensure that the user or process executing this command has the necessary permissions to do so. This could potentially allow unauthorized deletion of data.\n\nMoreover, the deletion of a global node could lead to inconsistencies in the data if there are references or indexes pointing to the deleted node. This could lead to unexpected behavior or errors in the application.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before executing sensitive operations such as global node deletion. This can be achieved by using the `$SYSTEM.Security.Check()` method provided by InterSystems IRIS to verify if the current user has the necessary permissions to perform the operation.\n\nIn addition, it is important to maintain referential and index consistency when deleting global nodes. This could involve updating or deleting any references or indexes that point to the node being deleted.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nset resource = \"MyResource\"\nset permission = \"RW\"\nset result = $SYSTEM.Security.Check(resource, permission)\nif 'result {\n    write \"Insufficient privileges to delete node\",!\n    quit\n}\n// Perform any necessary referential/index consistency maintenance here\nkill ^PersonI(\"DOB\", currentintdob, id)\n```\n\nIn this code, the `$SYSTEM.Security.Check()` method is used to check if the current user has read-write (`RW`) permissions for the `MyResource` resource. If the user does not have the necessary permissions, the operation is aborted and a message is displayed.\n\nPlease note that this is just a code-level mitigation. Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. Also, environment safeguards and real logging/auditing should be in place.\n\n## References\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "cafcafb1-54e4-3005-a9fe-3fd052454113",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry1.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 1,
                  "endLine": 8,
                  "endColumn": 27,
                  "snippet": {
                    "text": "  read !, \"Phone: \", phone"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e826f109c4b45f10eee9761c945719176bc6b4aa43aa8b528eecb0f23972e1e9",
            "glog-pfp-ruleFileCode/v1": "4d988c25ff43dbdbaf7a05cd1696f869fd7cba05aa4552c4982d3b4e94de80dd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "4d988c25ff43dbdbaf7a05cd1696f869fd7cba05aa4552c4982d3b4e94de80dd"
          },
          "properties": {}
        },
        {
          "ruleId": "29b13a5d-59a3-3bdc-bf3b-705753a4df6b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry1.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 1,
                  "endLine": 6,
                  "endColumn": 26,
                  "snippet": {
                    "text": "  read !, \"Name: \" , name"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1eb0a19967bdf3a84b461d73a43ca1d67a24b112574176098cd2c9bc56d8ec1f",
            "glog-pfp-ruleFileCode/v1": "9a56055f23c0da538635528a49f93c4c2289ddec20bf6ba59bf5a8760bbe5f4e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9a56055f23c0da538635528a49f93c4c2289ddec20bf6ba59bf5a8760bbe5f4e"
          },
          "properties": {}
        },
        {
          "ruleId": "435010c9-558e-3363-b9d6-0240e98604bb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 1,
                  "endLine": 15,
                  "endColumn": 25,
                  "snippet": {
                    "text": "  read !, \"Name: \", name"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1588fd68e296aefb65029f3ddd8a6aa0477c00f7d05c9f86e8e3ac695b8f4a04",
            "glog-pfp-ruleFileCode/v1": "c106970a3015e1768d0c46da207f0b746f250550d6e18743983cea2298ec866b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c106970a3015e1768d0c46da207f0b746f250550d6e18743983cea2298ec866b"
          },
          "properties": {}
        },
        {
          "ruleId": "dde36b30-4084-3114-9c88-74272d0a459d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry1.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 1,
                  "endLine": 10,
                  "endColumn": 1,
                  "snippet": {
                    "text": "  read !, \"DOB: \", dob"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "a16517c0f7a1862ad00bed6bab01410c3c653d18c2f71619a8ffc6c248854784",
            "glog-pfp-ruleFileCode/v1": "f18002dcec8b804fc4aff86ddc75b0318e4aa913b880f394fc091504f48d1af0"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f18002dcec8b804fc4aff86ddc75b0318e4aa913b880f394fc091504f48d1af0"
          },
          "properties": {}
        },
        {
          "ruleId": "4e6b4276-0f0e-32cd-8208-0994f0e7ce53",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 1,
                  "endLine": 18,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  read !, \"DOB: \", dob"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5751a49c2db36846c77ea9f6320c4c2775bf22601f0d6786d67653555592de83",
            "glog-pfp-ruleFileCode/v1": "f68b5162038558ce480a5a02eef7addf417debda8710a3a71119858aab2e0b0c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f68b5162038558ce480a5a02eef7addf417debda8710a3a71119858aab2e0b0c"
          },
          "properties": {}
        },
        {
          "ruleId": "a812b057-eba4-3975-85d0-6cb81435013b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Validation Vulnerability: No Length Limit, Suggest Adding #maxlen for Enhanced Security\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 3,
                  "endLine": 22,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"Phone (617): \", phone\n  } while '..ValidPhone(.phone)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "aa241c83c46100896efcf086be922b16a9d5bbf34ebe222e5e7231ccd43bcf56",
            "glog-pfp-ruleFileCode/v1": "17f42aea76a5e604c169425e393560120a0b62ef05cdf5447627310284e761c3"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "17f42aea76a5e604c169425e393560120a0b62ef05cdf5447627310284e761c3"
          },
          "properties": {}
        },
        {
          "ruleId": "cd5c0c9e-441e-3ab5-ae94-990b4540352a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Vulnerability Due to Lack of Length Limit: Consider Implementing #maxlen for Enhanced Security\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 3,
                  "endLine": 18,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"Name: \", name\n    return:(name = \"\") 0  // user entered nothing so return FALSE, exit loop AND method\n  } while '..ValidName(name)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "88330178e5906f5a327710de523a76fc6012996262e842edc3d3ef9e40b52042",
            "glog-pfp-ruleFileCode/v1": "72f9cb269d60974d2dec07781c8313d932a75856831e71295bf90cefa4d10a8a"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "72f9cb269d60974d2dec07781c8313d932a75856831e71295bf90cefa4d10a8a"
          },
          "properties": {}
        },
        {
          "ruleId": "6c9216c5-1199-3e3d-be32-76444508b497",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 1,
                  "endLine": 17,
                  "endColumn": 27,
                  "snippet": {
                    "text": "  read !, \"Phone: \", phone"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f88fed0aa0791482ac2ccafcd80ab66c6fd9df6132b217e52ac397e114e40ec3",
            "glog-pfp-ruleFileCode/v1": "bdb55c573e4c113c915bdee6240a0a5f7481ccdaf9736a6b7f6b9901f2e6ef18"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "bdb55c573e4c113c915bdee6240a0a5f7481ccdaf9736a6b7f6b9901f2e6ef18"
          },
          "properties": {}
        },
        {
          "ruleId": "3ed646f7-709c-3f10-a7ac-befa9871452f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 3,
                  "endLine": 26,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"DOB: \", dob\n  } while '..ValidDOB(dob, .intdob)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e6d0ee4d2d6533856c3de647e91454b57aa63cb689353fc9e354fd62284dafac",
            "glog-pfp-ruleFileCode/v1": "94dc920180ff2b72d37f7c85a52814c9cf11f1d1042a584c14a23c0cc8b7f587"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "94dc920180ff2b72d37f7c85a52814c9cf11f1d1042a584c14a23c0cc8b7f587"
          },
          "properties": {}
        },
        {
          "ruleId": "499a80f3-9d51-308a-a8b7-d54e1e77d26a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 3,
                  "endLine": 27,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"DOB: \", dob\n  } While '..ValidDOB(dob, .intdob)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "12d7de5090d32ba81c31cd35728ebdb7f7dae490f24ead4f33f52990efc9ff5f",
            "glog-pfp-ruleFileCode/v1": "eace1c7a8f7c366eb78748ab636f9891fd378660c60dd6167f5e8b1c77ed71cd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "eace1c7a8f7c366eb78748ab636f9891fd378660c60dd6167f5e8b1c77ed71cd"
          },
          "properties": {}
        },
        {
          "ruleId": "42493282-59f2-325f-a414-89b76af33cf1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Function Vulnerability: Lack of Length Limit and Need for #maxlen Implementation\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 3,
                  "endLine": 19,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"Name: \", name\n    return:(name = \"\") 0  // user entered nothing so return FALSE, exit loop AND method\n  } While '..ValidName(name)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "a26a27f1f7759a90be695423e71456f39c405514740fb649ed46101e1f4cce8a",
            "glog-pfp-ruleFileCode/v1": "b7eef19b46d93b7571a649686a9292b219f18d52d1f86e4406b849c6e49c91f1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "b7eef19b46d93b7571a649686a9292b219f18d52d1f86e4406b849c6e49c91f1"
          },
          "properties": {}
        },
        {
          "ruleId": "54211a2f-95e9-3e07-897e-253a1bd9dc64",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 3,
                  "endLine": 23,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"Phone (617): \", phone\n  } While '..ValidPhone(.phone)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2224ea682cca3496a5065321a9b213e3b1c825283f2c495757f70f950307605b",
            "glog-pfp-ruleFileCode/v1": "0526502925ea06aca6d1dfb2d861bdb9d35e6a60becfaf6287af14ebcb3c3c6e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0526502925ea06aca6d1dfb2d861bdb9d35e6a60becfaf6287af14ebcb3c3c6e"
          },
          "properties": {}
        },
        {
          "ruleId": "5ec0f754-a889-33c5-965e-aa50f1b6348e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential race condition in uniqueness check with separate SET method: consider using LOCK for validate-store operation."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 5,
                  "endLine": 56,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    if $data(^PersonI(\"Phone\", phone)) {\n      write !, \"Phone number already in use\"\n      return 0"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "d9ffcb402aaefee9aafdeb7fbd1e0302b89f01ce1dc7e0ae4d276782c216d4ae",
            "glog-pfp-ruleFileCode/v1": "3380a87a09c4db7b2f36452d037308798a281171de8ab560de6475418f15d5dd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3380a87a09c4db7b2f36452d037308798a281171de8ab560de6475418f15d5dd"
          },
          "properties": {}
        },
        {
          "ruleId": "bf4b8989-114a-35f2-b7a6-e46ab8b15089",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Consider using TSTART/TCOMMIT for consistency when multiple related SETs follow $INCREMENT outside transaction."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 1,
                  "endLine": 110,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n  set id = $increment(^PersonD)  // use $increment to generate a new ID"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "8b24776f23797e5a44e106662418a1549d9214b4c7ac7baeb8a2c6f3ab9e3afd",
            "glog-pfp-ruleFileCode/v1": "135fdad62d87be0a6f530642f119c099171187f5db1c23973e0728a2ad18667c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "135fdad62d87be0a6f530642f119c099171187f5db1c23973e0728a2ad18667c"
          },
          "properties": {}
        },
        {
          "ruleId": "472c15e6-ffcc-3a94-8295-65e61fb52e2d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Data Reset Pattern Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 1,
                  "endLine": 137,
                  "endColumn": 9,
                  "snippet": {
                    "text": "ClassMethod Load()\n{\n  kill ^PersonD, ^PersonI"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e46d2a30aa0d31f66fc3c4492caeab96a9e23b5f5e3d2441fd797183e8a8944b",
            "glog-pfp-ruleFileCode/v1": "2c9e244929f3b8095ba97e90535f6a3b94412ed8b8caf76810149bf00d84ef9f"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2c9e244929f3b8095ba97e90535f6a3b94412ed8b8caf76810149bf00d84ef9f"
          },
          "properties": {}
        },
        {
          "ruleId": "b7d2889e-cb47-33e2-86e2-13bf33b98386",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Unprotected Transaction Block Vulnerability with Error Handling via Try/Catch and TROLLBACK\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 3,
                  "endLine": 130,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  tstart\n  set ^PersonD(id) = answers  // store the answers\n\n  set $listbuild(name, phone, intdob) = answers\n  // split name into last and first for storage in index\n  set last = $piece(name, \",\", 1), first = $piece(name, \",\", 2)\n\n\t/* the next three statements store data in subscripts.\n  because of the automatic sorting of subscripts,\n  this has the effect of building 3 indices: name, phone, and DOB */\n  set ^PersonI(\"Name\", last, first, id) = \"\"  // index last and first name\n  set ^PersonI(\"Phone\", phone) = id           // index the UNIQUE phone\n  set ^PersonI(\"DOB\", intdob, id) = \"\"        // index the internal DOB\n\n\t/* these statements turn the id into a \"chunk #\" and a \"position #\"\n  and set a bit into the bitmap index */\n  set chunk = (id\\64000) + 1, position = (id#64000) + 1\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 1\n  tcommit"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5b7be2c20a33b3d2a258344cb731f430ec11b3ddbc054b69dab7828a318fe75c",
            "glog-pfp-ruleFileCode/v1": "8205c180161f40bf01a292183503ab96dd94245da5f906dd4b394539173317d8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8205c180161f40bf01a292183503ab96dd94245da5f906dd4b394539173317d8"
          },
          "properties": {}
        },
        {
          "ruleId": "01879d89-0731-3f2d-8f28-222b8397169c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Global Root Deletion: Admin-Only Access, Not for Production Use\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 137,
                  "startColumn": 1,
                  "endLine": 137,
                  "endColumn": 26,
                  "snippet": {
                    "text": "  kill ^PersonD, ^PersonI"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f7acc2d8fb698b79dbe5f1419cfb25ea127a904bf8965d4259905f2cd4f7f53e",
            "glog-pfp-ruleFileCode/v1": "71bf54ba2a9144e1b91e28200b017cdf95ff6c26b1370006bc6cd7ee99d51ff9"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "71bf54ba2a9144e1b91e28200b017cdf95ff6c26b1370006bc6cd7ee99d51ff9"
          },
          "properties": {}
        },
        {
          "ruleId": "4d0c456f-a42e-311e-b69e-14311e702bb7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Admin-Only Restriction Required for Detected Extent Deletion Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 35,
                  "endLine": 138,
                  "endColumn": 47,
                  "snippet": {
                    "text": "  do ##class(ObjectScript.Person).%KillExtent()"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "85887d486731a3fbc39cb1daf9906e7d01cc348c959a812be3eef71a9837b677",
            "glog-pfp-ruleFileCode/v1": "4490d8d8e00d0a76642c1ef08ef845f36dc24664bbc7b8c452933a22ce1968a3"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "4490d8d8e00d0a76642c1ef08ef845f36dc24664bbc7b8c452933a22ce1968a3"
          },
          "properties": {}
        },
        {
          "ruleId": "e4b58409-487c-3a5f-93f3-358dcf66133a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Validation Lacks Length Limit Despite Match/Pattern Verification\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 1,
                  "endLine": 26,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  read !, \"Lookup: \", lookup\n  return:(lookup = \"\") 0  // user entered nothing so return FALSE\n  if (lookup = \"?\") {\n    set type = \"help\", search = \"\"\n  }\n  // the RegEx accepts ###- or ###-###-#### only\n  elseif $match(lookup, \"\\d{3}-(\\d{3}-\\d{4})?\") {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7ebb7b591794a34ddfcee13e44218813c1fd694d9c58578fbf241320436c6e0c",
            "glog-pfp-ruleFileCode/v1": "d42ee2aee074bd9274ccd3d08e7d620fa345b7c23d07ebfc5c7418898b1b7613"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "d42ee2aee074bd9274ccd3d08e7d620fa345b7c23d07ebfc5c7418898b1b7613"
          },
          "properties": {}
        },
        {
          "ruleId": "1f4724ef-1c72-3b83-aac4-2e58ac0c7a18",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Validation Lacks Length Limit Despite Match/Pattern Verification\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 1,
                  "endLine": 26,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  read !, \"Lookup: \", lookup\n  return:(lookup = \"\") 0  // user entered nothing so return FALSE\n  if (lookup = \"?\") {\n    set type = \"help\", search = \"\"\n  }\n  // the RegEx accepts ###- or ###-###-#### only\n  elseif $match(lookup, \"\\d{3}-(\\d{3}-\\d{4})?\") {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c369cf38a9c01c51c8e1910e8f167d7748ea16733959a50b230ad1163fe5857e",
            "glog-pfp-ruleFileCode/v1": "50697fdb20a31b2a0f51c7ac791d19a58529da92d4791f879ba2e621eaf0936d"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "50697fdb20a31b2a0f51c7ac791d19a58529da92d4791f879ba2e621eaf0936d"
          },
          "properties": {}
        },
        {
          "ruleId": "29ee34b7-ccf0-30dd-b66b-6f7bc6735d1b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Unprotected Transaction Block Vulnerability with Error Handling via Try/Catch and TROLLBACK\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 226,
                  "startColumn": 3,
                  "endLine": 232,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  tstart\n  kill ^PersonD(id)\n  kill ^PersonI(\"Name\", last, first, id)\n  kill ^PersonI(\"Phone\", phone)\n  kill ^PersonI(\"DOB\", intdob, id)\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 0\n  tcommit"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "524a8872c2c71713c7d233796ce2436aa88e403eae222244eba769be399d226c",
            "glog-pfp-ruleFileCode/v1": "6d4ad56227d20f25898055bfda0ca64e27ba177955c1efc72131748ef0ad1950"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "6d4ad56227d20f25898055bfda0ca64e27ba177955c1efc72131748ef0ad1950"
          },
          "properties": {}
        },
        {
          "ruleId": "72d80781-e079-3971-b3e2-6b71b145a3f1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 227,
                  "startColumn": 1,
                  "endLine": 227,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonD(id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ba0fc87304c8cfdd7a5ae46bbd6732cb705590a374a0af6c559ee98fd900fc06",
            "glog-pfp-ruleFileCode/v1": "fbfa074c25598a93d276a65d1cd8f7625c3162ef0859e7ae8e56ed97364861dd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "fbfa074c25598a93d276a65d1cd8f7625c3162ef0859e7ae8e56ed97364861dd"
          },
          "properties": {}
        },
        {
          "ruleId": "20132af7-7e3c-31be-bd4f-af6dee00c8e0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 228,
                  "startColumn": 1,
                  "endLine": 228,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonI(\"Name\", last, first, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "39ccfa5bfee025a32458dd23f11fa0fbde5a5e84975962b13a6dc5c3c7935ff7",
            "glog-pfp-ruleFileCode/v1": "9cc9bcc620932ba42597e1a6210b9aa47ad40853372fda4cf8a57843ca87c6d3"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9cc9bcc620932ba42597e1a6210b9aa47ad40853372fda4cf8a57843ca87c6d3"
          },
          "properties": {}
        },
        {
          "ruleId": "80e5bcc0-bd1f-325f-881b-f661c4d44193",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 229,
                  "startColumn": 1,
                  "endLine": 229,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonI(\"Phone\", phone)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f6bce1cae137605db71abc33ba5171de8773f03c266f9ae5b8b2571cc8f993c6",
            "glog-pfp-ruleFileCode/v1": "8c64b374d9bba1d82fb6a3e95720ba33c7ba16252397344301bf24bc84a6d6e1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8c64b374d9bba1d82fb6a3e95720ba33c7ba16252397344301bf24bc84a6d6e1"
          },
          "properties": {}
        },
        {
          "ruleId": "1c63cc4b-0cc5-3298-8eb0-523a47135950",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 230,
                  "startColumn": 1,
                  "endLine": 230,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonI(\"DOB\", intdob, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ae317b0b2529d136a98727ca20c860a5f69130866ce7764ab51296235befc3f1",
            "glog-pfp-ruleFileCode/v1": "72280b74bd40d6c1b6730110938a1ed6931199110b9f9e2b968194cfea2c44ce"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "72280b74bd40d6c1b6730110938a1ed6931199110b9f9e2b968194cfea2c44ce"
          },
          "properties": {}
        },
        {
          "ruleId": "1796d0d6-cb26-353c-bf29-b10f6a8320b8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Vulnerability of Unhandled Errors in Transaction Block without Rollback Mechanism\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 310,
                  "startColumn": 3,
                  "endLine": 327,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  tstart\n  set ^PersonD(id) = newanswers\n  if (newname '= currentname) {\n    // kill old name and add new name to index\n    kill ^PersonI(\"Name\", currentlast, currentfirst, id)\n    set ^PersonI(\"Name\", newlast, newfirst, id) = \"\"\n  }\n  if (newphone '= currentphone) {\n    // kill old phone and add new phone to index\n    kill ^PersonI(\"Phone\", currentphone)\n    set ^PersonI(\"Phone\", newphone) = id\n  }\n  if (newintdob '= currentintdob) {\n    // kill old dob and add new dob to index\n    kill ^PersonI(\"DOB\", currentintdob, id)\n    set ^PersonI(\"DOB\", newintdob, id) = \"\"\n  }\n  tcommit  // commit the transaction"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "eea00ea157f2529b3bbabc4f5e20dc33d25f70cf3ead49ab062e1d7158728039",
            "glog-pfp-ruleFileCode/v1": "7d97a0da241969d8b6bc1b8ef7d29dc93357400c5eebe15494f8c5338fd2ade8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7d97a0da241969d8b6bc1b8ef7d29dc93357400c5eebe15494f8c5338fd2ade8"
          },
          "properties": {}
        },
        {
          "ruleId": "8ce05a7d-fb70-3819-9558-f376f862e78e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 314,
                  "startColumn": 1,
                  "endLine": 314,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    kill ^PersonI(\"Name\", currentlast, currentfirst, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "549252a2a90c1958ff803d2a3c54e0e499f769457676cd390c226e4576cd765e",
            "glog-pfp-ruleFileCode/v1": "c2e3657171377b6ae29f818e99747196ae676817b036847bda59fb29f8bc456b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c2e3657171377b6ae29f818e99747196ae676817b036847bda59fb29f8bc456b"
          },
          "properties": {}
        },
        {
          "ruleId": "5a8eaf42-0bfb-34db-9b94-e596fca1725d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 319,
                  "startColumn": 1,
                  "endLine": 319,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    kill ^PersonI(\"Phone\", currentphone)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "811ecacde85f4a18d3a70ef32bdb6c98ef22c90eafe44b1a2361d821cbcfed55",
            "glog-pfp-ruleFileCode/v1": "08d790c5f05b94539a31cab33d359f9a0a2e5984fb4fc75e29a9a8a43d1419eb"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "08d790c5f05b94539a31cab33d359f9a0a2e5984fb4fc75e29a9a8a43d1419eb"
          },
          "properties": {}
        },
        {
          "ruleId": "33f20dda-eb54-3410-96f5-2d82070864bf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 1,
                  "endLine": 324,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    kill ^PersonI(\"DOB\", currentintdob, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "080f2e69363b80969258314e19cf7dcee5d1c69c12150f348c143c8f7601d902",
            "glog-pfp-ruleFileCode/v1": "0418632810a07515c059cac234c6be7ec2cb747aae142d87bf017991cf6a047f"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0418632810a07515c059cac234c6be7ec2cb747aae142d87bf017991cf6a047f"
          },
          "properties": {}
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}