{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "29b13a5d-59a3-3bdc-bf3b-705753a4df6b",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a denial of service (DoS) via resource exhaustion by providing an excessively large input. This vulnerability occurs when the application does not properly limit the size of user-supplied input.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the size of the input that can be read. This can be achieved by reading the input into a temporary variable and then checking the length of the input before assigning it to the actual variable. If the input exceeds the expected length, the application should reject the input and possibly alert the user.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix for the vulnerability:\n\n```objectscript\nread !, \"Name: \", temp\nif $length(temp) > MAX_LENGTH {\n    write !, \"Input is too long. Please enter a name up to \", MAX_LENGTH, \" characters.\"\n} else {\n    set name = temp\n}\n```\n\nIn this code, `MAX_LENGTH` is a constant that defines the maximum allowed length of the input.\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that in addition to the source code fix, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution to prevent unauthorized access."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "435010c9-558e-3363-b9d6-0240e98604bb",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a denial of service (DoS) via resource exhaustion by providing an excessively large input. This vulnerability occurs when the application does not properly limit the size of user-supplied input. \n\nIn the provided code snippet:\n\n```objectscript\nread !, \"Name: \", name\n```\n\nThe `read` command is used to get user input without any restrictions on the size of the input. This can lead to excessive consumption of system resources (CPU/memory), causing the application to slow down or crash, resulting in a denial of service.\n\n## Mitigation\n\nTo mitigate this vulnerability, you should enforce input validation and limit the size of the user input. This can be achieved by reading the input into a temporary variable, checking its length, and then assigning it to the `name` variable if it meets the criteria.\n\nHere is a code fix recommendation:\n\n```objectscript\nread !, \"Name: \", temp\nif $length(temp) > 100 {\n    write \"Input is too long. Please enter a name up to 100 characters.\"\n} else {\n    set name = temp\n}\n```\n\nIn this example, the input length is limited to 100 characters. If the user input exceeds this limit, an error message is displayed.\n\n## Library Dependencies\n\nThe provided code snippet does not require any additional library dependencies to execute properly.\n\n## Additional Security Measures\n\nIn addition to the proposed solution in the source code, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution to prevent unauthorized access.\n\n## References\n\n- [OWASP Unrestricted File Upload](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n- [CWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion')](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "dde36b30-4084-3114-9c88-74272d0a459d",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a denial of service (DoS) via resource exhaustion by providing an excessively large input. This vulnerability occurs when the program does not properly restrict the size of input that can be read, allowing an attacker to consume excessive resources, such as CPU or memory.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the size of the input that can be read. This can be achieved by reading the input into a variable and then checking the length of the input. If the input exceeds the expected length, the program should reject the input and possibly alert the user.\n\nIn addition to the source code fix, it is important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This will ensure that only authorized users can interact with the application, reducing the risk of an attack.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability in the provided code:\n\n```objectscript\nread !, \"DOB: \", dob\nif $LENGTH(dob) > expectedLength {\n    write \"Input is too long. Please enter a valid DOB.\"\n    quit\n}\n```\n\nReplace `expectedLength` with the maximum length of input that your program expects.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "6262da2e-9f37-3863-8dc3-3638cd990cec",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a denial of service (DoS) via resource exhaustion by providing an excessively large input. This vulnerability occurs when the application does not properly limit the size of user-supplied input. \n\nIn the provided code snippet:\n\n```objectscript\nread !, \"Name: \", name\n```\n\nThe `read` command is used to get user input without any restrictions on the size of the input. This can lead to excessive consumption of system resources (CPU/memory), causing the application to slow down or crash, resulting in a denial of service.\n\n## Mitigation\n\nTo mitigate this vulnerability, you should enforce input validation and limit the size of the user input. This can be achieved by reading the input into a temporary variable, checking its length, and then assigning it to the `name` variable if it meets the criteria.\n\nHere is a code fix recommendation:\n\n```objectscript\nread !, \"Name: \", temp\nif $length(temp) > 100 {\n    write \"Input is too long. Please enter a name up to 100 characters.\"\n} else {\n    set name = temp\n}\n```\n\nIn this example, the input length is limited to 100 characters. If the user input exceeds this limit, an error message is displayed.\n\n## Library Dependencies\n\nThe provided code snippet does not require any additional library dependencies to execute properly.\n\n## Additional Security Measures\n\nIn addition to the proposed solution in the source code, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution to prevent unauthorized access.\n\n## References\n\n- [OWASP Unrestricted File Upload](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n- [CWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion')](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "cafcafb1-54e4-3005-a9fe-3fd052454113",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a Denial of Service (DoS) via resource exhaustion by providing an excessively large input. This is due to the fact that the `read` command in ObjectScript does not limit the size of the input it accepts.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the size of the input that can be accepted. This can be done by reading the input into a variable and then checking the length of the input. If the input exceeds the maximum allowed length, an error message should be displayed and the input should be discarded.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix for the vulnerability:\n\n```objectscript\nread !, \"Phone: \", phone\nif $length(phone) > 20 { // assuming 20 is the maximum allowed length\n    write !, \"Input is too long. Please enter a phone number of 20 characters or less.\"\n    quit\n}\n```\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## OWASP and CWE Resources\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\n## Note\n\nIn addition to the source code fix, it is important to enforce authorization using IRIS security (resources/roles) and/or application authentication as a primary solution to access control issues."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "8c7bf338-f401-35aa-a1af-2aed24c41f33",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a denial of service (DoS) via resource exhaustion by providing an excessively large input. This vulnerability occurs when the program does not properly restrict the size of input that can be read, allowing an attacker to consume excessive resources, such as CPU or memory.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the size of the input that can be read. This can be achieved by reading the input into a variable and then checking the length of the input. If the input exceeds the expected length, the program should reject the input and possibly alert the user.\n\nIn addition to the source code fix, it is important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This will ensure that only authorized users can interact with the application, reducing the risk of an attack.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability in the provided code:\n\n```objectscript\nread !, \"DOB: \", dob\nif $LENGTH(dob) > expectedLength {\n    write \"Input is too long. Please enter a valid DOB.\"\n    quit\n}\n```\n\nReplace `expectedLength` with the maximum length of input that your program expects.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "b80c2cbe-37b4-3abc-99db-55964d1ec4fd",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a denial of service (DoS) via resource exhaustion by providing an excessively large input. This vulnerability occurs when the application does not properly limit the size of user-supplied input. \n\nIn the provided code snippet:\n\n```objectscript\nread !, \"Name: \", name\n```\n\nThe `read` command is used to get user input without any restrictions on the size of the input. This can lead to excessive consumption of system resources (CPU/memory), causing the application to slow down or crash, resulting in a denial of service.\n\n## Mitigation\n\nTo mitigate this vulnerability, you should enforce input validation and limit the size of the user input. This can be achieved by reading the input into a temporary variable, checking its length, and then assigning it to the `name` variable if it meets the criteria.\n\nHere is a code fix recommendation:\n\n```objectscript\nread !, \"Name: \", temp\nif $length(temp) > 100 {\n    write \"Input is too long. Please enter a name up to 100 characters.\"\n} else {\n    set name = temp\n}\n```\n\nIn this example, the input length is limited to 100 characters. If the user input exceeds this limit, an error message is displayed.\n\n## Library Dependencies\n\nThe provided code snippet does not require any additional library dependencies to execute properly.\n\n## Additional Security Measures\n\nIn addition to the proposed solution in the source code, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution to prevent unauthorized access.\n\n## References\n\n- [OWASP Unrestricted File Upload](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n- [CWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion')](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "4e6b4276-0f0e-32cd-8208-0994f0e7ce53",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a denial of service (DoS) via resource exhaustion by providing an excessively large input. This vulnerability occurs when the program does not properly restrict the size of input that can be read, allowing an attacker to consume excessive resources, such as CPU or memory.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the size of the input that can be read. This can be achieved by reading the input into a variable and then checking the length of the input. If the input exceeds the expected length, the program should reject the input and possibly alert the user.\n\nIn addition to the source code fix, it is important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This will ensure that only authorized users can interact with the application, reducing the risk of an attack.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability in the provided code:\n\n```objectscript\nread !, \"DOB: \", dob\nif $LENGTH(dob) > expectedLength {\n    write \"Input is too long. Please enter a valid DOB.\"\n    quit\n}\n```\n\nReplace `expectedLength` with the maximum length of input that your program expects.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "30f6178e-b133-3574-a907-c0d46fcb113b",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a denial of service (DoS) via resource exhaustion by providing an excessively large input. This vulnerability occurs when the program does not properly restrict the size of input that can be read, allowing an attacker to consume excessive resources, such as CPU or memory.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the size of the input that can be read. This can be achieved by reading the input into a variable and then checking the length of the input. If the input exceeds the expected length, the program should reject the input and possibly alert the user.\n\nIn addition to the source code fix, it is important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This will ensure that only authorized users can interact with the application, reducing the risk of an attack.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability in the provided code:\n\n```objectscript\nread !, \"DOB: \", dob\nif $LENGTH(dob) > expectedLength {\n    write \"Input is too long. Please enter a valid DOB.\"\n    quit\n}\n```\n\nReplace `expectedLength` with the maximum length of input that your program expects.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "5c60e801-55ef-3dc8-9c74-d3d32c337f6f",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a denial of service (DoS) via resource exhaustion by providing an excessively large input. This vulnerability occurs when the application does not properly limit the size of user-supplied input. \n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the size of the input that can be read. This can be achieved by reading the input into a temporary variable, then checking the length of the input and only assigning it to the actual variable if it meets the length requirements. \n\nAdditionally, it is important to enforce authorization using IRIS security (resources/roles) and/or application authentication as a primary solution.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix:\n\n```objectscript\nread !, \"Phone (617): \", temp\nif $length(temp) <= 10 {\n    set phone = temp\n} else {\n    write \"Input too long. Please enter a valid phone number.\"\n}\n```\n\nIn this code, the input is first read into a temporary variable `temp`. Then, the length of the input is checked. If it is less than or equal to 10 (the maximum length of a phone number), it is assigned to the `phone` variable. If it is longer, an error message is displayed.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are active and accessible to anonymous users."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "6c9216c5-1199-3e3d-be32-76444508b497",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a Denial of Service (DoS) via resource exhaustion by providing an excessively large input. This is due to the fact that the `read` command in ObjectScript does not limit the size of the input it accepts.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the size of the input that can be accepted. This can be done by reading the input into a variable and then checking the length of the input. If the input exceeds the maximum allowed length, an error message should be displayed and the input should be discarded.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix for the vulnerability:\n\n```objectscript\nread !, \"Phone: \", phone\nif $length(phone) > 20 { // assuming 20 is the maximum allowed length\n    write !, \"Input is too long. Please enter a phone number of 20 characters or less.\"\n    quit\n}\n```\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## OWASP and CWE Resources\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\n## Note\n\nIn addition to the source code fix, it is important to enforce authorization using IRIS security (resources/roles) and/or application authentication as a primary solution to access control issues."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "66c2c5c0-c92b-328a-bb77-0c54a329b0d9",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a denial of service (DoS) via resource exhaustion by providing an excessively large input. This vulnerability occurs when the application does not properly limit the size of user-supplied input. \n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the size of the input that can be read. This can be achieved by reading the input into a temporary variable, then checking the length of the input and only assigning it to the actual variable if it meets the length requirements. \n\nAdditionally, it is important to enforce authorization using IRIS security (resources/roles) and/or application authentication as a primary solution.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix:\n\n```objectscript\nread !, \"Phone (617): \", temp\nif $length(temp) <= 10 {\n    set phone = temp\n} else {\n    write \"Input too long. Please enter a valid phone number.\"\n}\n```\n\nIn this code, the input is first read into a temporary variable `temp`. Then, the length of the input is checked. If it is less than or equal to 10 (the maximum length of a phone number), it is assigned to the `phone` variable. If it is longer, an error message is displayed.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are active and accessible to anonymous users."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "bf4b8989-114a-35f2-b7a6-e46ab8b15089",
              "name": "Consider using TSTART/TCOMMIT for consistency when multiple related SETs follow an INCREMENT outside transaction.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn InterSystems ObjectScript, the `$increment` function is used to atomically increment a global or local variable. However, when multiple related `SET` operations follow an `INCREMENT` outside of a transaction, it can lead to inconsistencies. This is because if an error occurs during one of the `SET` operations, the `INCREMENT` will not be rolled back, leading to a potential loss of data integrity.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use the `TSTART` and `TCOMMIT` commands to ensure that the `INCREMENT` and subsequent `SET` operations are treated as a single atomic transaction. If an error occurs during any part of the transaction, the entire transaction will be rolled back, preserving data integrity.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```objectscript\nTSTART\nset id = $increment(^PersonD)  // use $increment to generate a new ID\n// ... other related SET operations ...\nif $TLEVEL TCOMMIT\n```\n\nIn this code, `TSTART` begins a transaction, and `TCOMMIT` commits the transaction if it is successful. If an error occurs during any of the `SET` operations, the transaction will be rolled back, and the `INCREMENT` will not take effect.\n\n## Library Dependencies\n\nThe provided code does not require any library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP - Insecure Direct Object References](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution for dealing with access control issues."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-362"
                ]
              }
            },
            {
              "id": "5ec0f754-a889-33c5-965e-aa50f1b6348e",
              "name": "Potential Race Condition in Data Uniqueness Check with Separate Set Method: Consider Lock During Validate-Store Operation.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe code snippet provided is vulnerable to a potential race condition during the check for data uniqueness. This occurs when two or more concurrent threads perform a check for the uniqueness of a phone number and then set it if it doesn't exist. If the check and set operations are not atomic, it's possible for two threads to perform the check at the same time, both find that the phone number doesn't exist, and then both set the same phone number, violating the uniqueness constraint.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should ensure that the check and set operations are atomic. This can be achieved by using locks. In ObjectScript, you can use the `Lock` command to lock a global or local variable. Once a variable is locked by a process, other processes cannot change its value until the lock is released.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```objectscript\nlock (^PersonI(\"Phone\", phone)):5\nif $data(^PersonI(\"Phone\", phone)) {\n    write !, \"Phone number already in use\"\n    lock (^PersonI(\"Phone\", phone))\n    return 0\n}\n// set phone number\nlock (^PersonI(\"Phone\", phone))\n```\n\nIn this code, we first try to acquire a lock on the phone number. If we succeed, we then check if the phone number already exists. If it does, we release the lock and return. If it doesn't, we set the phone number and then release the lock.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies to execute properly.\n\n## References\n\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution when dealing with access control issues."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-362"
                ]
              }
            },
            {
              "id": "472c15e6-ffcc-3a94-8295-65e61fb52e2d",
              "name": "\"Data Reset Pattern Vulnerability\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Data Reset Pattern Vulnerability\" in ObjectScript is a type of vulnerability where an attacker can manipulate the data reset pattern to cause unexpected behavior in the application. In the provided code example, the `kill` command is used to delete all data in the `^PersonD` and `^PersonI` global arrays. If an attacker can influence the execution of this command, they could potentially delete critical data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should ensure that the `kill` command is only executed in a controlled manner. This could be achieved by implementing proper access controls to restrict who can execute this command. Additionally, you should validate and sanitize all inputs to prevent injection attacks.\n\n## Source Code Fix Recommendation\n\n```objectscript\nClassMethod Load()\n{\n    // Check if the user has the necessary permissions to execute this command\n    if $system.Security.Check(\"ResetData\", \"%Admin_Manage\") {\n        kill ^PersonD, ^PersonI\n    } else {\n        // Handle the error condition when the user does not have the necessary permissions\n        throw ##class(%Exception.PermissionDenied).%New(\"You do not have the necessary permissions to reset the data.\")\n    }\n}\n```\n\nIn this code, the `$system.Security.Check` method is used to check if the current user has the necessary permissions to execute the `kill` command. If they do not, an exception is thrown.\n\n## Library Dependencies\n\nThe provided code does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Resources\n\n- [OWASP Top 10 - A6:2017-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n- [CWE-639: Authorization Bypass Through User-Controlled Key](https://cwe.mitre.org/data/definitions/639.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution for dealing with access control issues."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-639",
                    "url": "https://cwe.mitre.org/data/definitions/639.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-639"
                ]
              }
            },
            {
              "id": "b7d2889e-cb47-33e2-86e2-13bf33b98386",
              "name": "\"Vulnerability of Unhandled Errors in Transaction Block without Rollback Mechanism\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability of \"Unhandled Errors in Transaction Block without Rollback Mechanism\" in ObjectScript programming language refers to the situation where an error occurs within a transaction block (`tstart` and `tcommit`), but there is no mechanism in place to handle the error and rollback the transaction. This can lead to data inconsistency and corruption, as some operations within the transaction block may have been executed while others have not.\n\nIn the provided code, if an error occurs after the `tstart` and before the `tcommit`, the changes made to the global variables `^PersonD` and `^PersonI` will not be rolled back. This can lead to data inconsistency and corruption.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, a `trollback` should be used in an error handling routine to rollback the transaction if an error occurs. This ensures that all changes made within the transaction block are undone if an error occurs, maintaining data consistency.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```objectscript\ntstart\ntry {\n  set ^PersonD(id) = answers  // store the answers\n\n  set $listbuild(name, phone, intdob) = answers\n  // split name into last and first for storage in index\n  set last = $piece(name, \",\", 1), first = $piece(name, \",\", 2)\n\n  /* the next three statements store data in subscripts.\n  because of the automatic sorting of subscripts,\n  this has the effect of building 3 indices: name, phone, and DOB */\n  set ^PersonI(\"Name\", last, first, id) = \"\"  // index last and first name\n  set ^PersonI(\"Phone\", phone) = id           // index the UNIQUE phone\n  set ^PersonI(\"DOB\", intdob, id) = \"\"        // index the internal DOB\n\n  /* these statements turn the id into a \"chunk #\" and a \"position #\"\n  and set a bit into the bitmap index */\n  set chunk = (id\\64000) + 1, position = (id#64000) + 1\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 1\n  tcommit\n} catch {\n  trollback\n  // handle the error\n}\n```\n\nIn this fix, a `try-catch` block is used to handle any errors that occur within the transaction block. If an error occurs, the `trollback` command is executed to rollback the transaction, and then the error is handled.\n\n## Library Dependencies\n\nThe provided code does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [CWE-391: Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution when dealing with access control issues."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-391",
                    "url": "https://cwe.mitre.org/data/definitions/391.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-391"
                ]
              }
            },
            {
              "id": "01879d89-0731-3f2d-8f28-222b8397169c",
              "name": "\"Global Root Deletion: Admin-Only Access, Not for Production Use\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"Global Root Deletion: Admin-Only Access, Not for Production Use\" in ObjectScript programming language refers to the unrestricted deletion of global variables. In the provided code snippet, `kill ^PersonD, ^PersonI` deletes the global variables `^PersonD` and `^PersonI`. This operation is potentially dangerous as it can lead to data loss if not properly controlled. \n\nThis vulnerability is particularly critical if the code is exposed to an interface where an attacker can execute it, as it allows for arbitrary deletion of data. It is also a concern if the code is executed in a context where it has more privileges than it should, leading to privilege escalation.\n\n## Mitigation\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Limit the use of the `kill` command to only those parts of the code that absolutely require it.\n2. Implement proper access controls to ensure that only authorized users can execute the `kill` command.\n3. Use InterSystems IRIS security features to enforce authorization and authentication.\n4. Validate and sanitize all inputs to prevent injection attacks.\n\n## Code Fix\n\nInstead of directly deleting the global variables, consider implementing a function that checks the user's permissions before executing the `kill` command. Here is an example:\n\n```objectscript\nClassMethod DeleteGlobalData() As %Status\n{\n    If $System.Security.Check(\"Admin\", \"%Admin_Secure\") {\n        kill ^PersonD, ^PersonI\n        Quit $$$OK\n    }\n    Else {\n        Quit $$$ERROR($$$Unauthorized)\n    }\n}\n```\n\nIn this example, the `Check` method of the `$System.Security` class is used to verify if the current user has the \"Admin\" role. If the user has the required role, the `kill` command is executed. Otherwise, an error is returned.\n\n## Library Dependencies\n\nThe provided code snippet does not require any external library dependencies to execute properly.\n\n## References\n\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "d17c8905-6da2-3b73-999c-52a5bdb2dac6",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a denial of service (DoS) via resource exhaustion by providing an excessively large input. This is due to the fact that the `READ` command in ObjectScript does not limit the size of the input it accepts. \n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the size of the input that can be accepted. This can be done by reading the input into a variable and then checking the length of the input. If the input exceeds the maximum allowed length, an error message should be displayed and the input should be discarded.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix:\n\n```objectscript\nread !, \"Lookup: \", lookup\nif $length(lookup) > MAX_LENGTH {\n    write !, \"Input is too long. Please enter a shorter lookup.\"\n    quit\n}\n```\n\nIn this code, `MAX_LENGTH` is a constant that defines the maximum allowed length of the input. This value should be set according to the specific requirements of your application.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP - Input Validation](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\n## Note\n\nIn addition to the source code fix, it is also important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This should be the primary solution for dealing with access control issues."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "1cb1c287-fdbb-3c33-bc9c-8e1f9d21e47d",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a denial of service (DoS) via resource exhaustion by providing an excessively large input. This is due to the fact that the `READ` command in ObjectScript does not limit the size of the input it accepts. \n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the size of the input that can be accepted. This can be done by reading the input into a variable and then checking the length of the input. If the input exceeds the maximum allowed length, an error message should be displayed and the input should be discarded.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix:\n\n```objectscript\nread !, \"Lookup: \", lookup\nif $length(lookup) > MAX_LENGTH {\n    write !, \"Input is too long. Please enter a shorter lookup.\"\n    quit\n}\n```\n\nIn this code, `MAX_LENGTH` is a constant that defines the maximum allowed length of the input. This value should be set according to the specific requirements of your application.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP - Input Validation](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\n## Note\n\nIn addition to the source code fix, it is also important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This should be the primary solution for dealing with access control issues."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "635e5a72-f3de-3630-bcf8-61e15f68ecc9",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a denial of service (DoS) via resource exhaustion by providing an excessively large input. This is due to the fact that the `READ` command in ObjectScript does not limit the size of the input it accepts. \n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the size of the input that can be accepted. This can be done by reading the input into a variable and then checking the length of the input. If the input exceeds the maximum allowed length, an error message should be displayed and the input should be discarded.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix:\n\n```objectscript\nread !, \"Lookup: \", lookup\nif $length(lookup) > MAX_LENGTH {\n    write !, \"Input is too long. Please enter a shorter lookup.\"\n    quit\n}\n```\n\nIn this code, `MAX_LENGTH` is a constant that defines the maximum allowed length of the input. This value should be set according to the specific requirements of your application.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP - Input Validation](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\n## Note\n\nIn addition to the source code fix, it is also important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This should be the primary solution for dealing with access control issues."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "4d0c456f-a42e-311e-b69e-14311e702bb7",
              "name": "\"Admin-Only Restriction Required for Detected Extent Deletion Vulnerability\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"Admin-Only Restriction Required for Detected Extent Deletion Vulnerability\" in ObjectScript programming language refers to the situation where an unauthorized user is able to delete an entire extent of data. This is a serious security issue as it can lead to data loss and unauthorized data manipulation. The vulnerability sink in this case is the `%KillExtent()` method, which deletes an entire extent of data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to implement proper access control mechanisms to restrict the use of the `%KillExtent()` method to only authorized users, typically administrators. This can be achieved by checking the user's role before executing the method. \n\nIn addition to the source code fix, it is also important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This should be the primary solution for dealing with access control issues.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how you can implement this in your code:\n\n```objectscript\nSet userRole = ##class(Security.Users).%OpenId($USERNAME).Roles\nIf userRole['%All' {\n    do ##class(ObjectScript.Person).%KillExtent()\n} else {\n    Write \"You do not have permission to perform this action.\"\n}\n```\n\nIn this example, the user's role is checked before executing the `%KillExtent()` method. If the user has the `%All` role (which typically represents an administrator), the method is executed. Otherwise, an error message is displayed.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Access Control Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "29ee34b7-ccf0-30dd-b66b-6f7bc6735d1b",
              "name": "\"Unprotected Transaction Block Vulnerability with Error Handling via Try/Catch and TROLLBACK\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the improper handling of transactions in the ObjectScript programming language. The code block is not protected by a try/catch block, which means that if an error occurs during the execution of the transaction, the transaction will not be rolled back. This can lead to inconsistent data states and potential data loss.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to wrap the transaction block within a try/catch block. This will ensure that if an error occurs during the transaction, the transaction will be rolled back to its previous state, preventing data inconsistencies and potential data loss.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability:\n\n```objectscript\ntry {\n  tstart\n  kill ^PersonD(id)\n  kill ^PersonI(\"Name\", last, first, id)\n  kill ^PersonI(\"Phone\", phone)\n  kill ^PersonI(\"DOB\", intdob, id)\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 0\n  tcommit\n} catch {\n  trollback\n  // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example does not appear to require any specific library dependencies to execute properly.\n\n## OWASP and CWE Resources\n\n- [OWASP - Error Handling](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n- [CWE - Unprotected Transaction Block](https://cwe.mitre.org/data/definitions/668.html)\n\nPlease note that in addition to the proposed solution in the source code, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution.\n\n## Note\n\nIn case of unbounded READ, do not report it as a buffer overflow vulnerability. In InterSystems ObjectScript (IRIS/Cach), strings are dynamically managed, not read into a fixed-size C-style buffer you control. In this case, If an attacker can supply very large input (typically in a network-exposed UI/API, not a local terminal), the concern is resource exhaustion / denial of service (memory/CPU), not buffer overflow. Also, have in mind that in ObjectScript, \":number\" on READ is a timeout in seconds, not a maximum number of characters. If you truly wanted a character limit, the syntax is # (fixed number of characters). \"#number\" fix is not a great idea here as this notation in ObjectScript means read exactly \"number\" characters, not up to number. Any extra characters the user typed can remain in the input buffer and be consumed by subsequent READs, which can cause confusing behavior. As a correct mitigation, keep the normal line READ, then enforce limits/validation."
              },
              "properties": {
                "cwe": [],
                "severity": "MEDIUM",
                "kind": "FAIL"
              }
            },
            {
              "id": "72d80781-e079-3971-b3e2-6b71b145a3f1",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the deletion of a global node in the ObjectScript programming language without proper authorization verification and referential/index consistency maintenance. This can lead to unauthorized data manipulation or deletion, and inconsistency in the database.\n\nIn the provided code snippet, `kill ^PersonD(id)` is used to delete a global node. However, there is no check to verify if the user has the necessary permissions to perform this action. Additionally, there is no mechanism in place to maintain referential integrity or index consistency after the deletion.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before allowing a user to delete a global node. This can be done by verifying the user's role and ensuring they have the necessary permissions to perform the action.\n\nAdditionally, referential integrity and index consistency should be maintained after the deletion. This can be achieved by implementing a mechanism to update all references to the deleted node and re-indexing the database if necessary.\n\n## Source Code Fix Recommendation\n\n```objectscript\nif $System.Security.Check(\"Delete Person\", \"%Admin\") {\n    kill ^PersonD(id)\n    // Add code here to maintain referential integrity and index consistency\n} else {\n    write \"You do not have the necessary permissions to perform this action.\"\n}\n```\n\nIn the above code, `$System.Security.Check(\"Delete Person\", \"%Admin\")` is used to verify if the user has the necessary permissions to delete a person. If they do, the global node is deleted. If not, an error message is displayed.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution to address access control issues."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "20132af7-7e3c-31be-bd4f-af6dee00c8e0",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the deletion of a global node in the ObjectScript programming language without proper authorization verification and referential/index consistency maintenance. In the provided code snippet, a `PersonI` node is being deleted without any checks for user permissions or the integrity of related data. This could potentially lead to unauthorized data manipulation or inconsistencies in the database.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before allowing a user to delete a global node. This can be achieved by verifying the user's role or permissions before executing the `kill` command. Additionally, it is important to ensure that the deletion of a node does not result in orphaned references or inconsistencies in the database. This can be done by implementing referential integrity checks or maintaining index consistency before and after the deletion operation.\n\n## Code Fix Recommendation\n\nHere is a simple example of how you might implement these mitigations in ObjectScript:\n\n```objectscript\nset authorized = ##class(Security.Users).IsAuthorizedRole(\"Admin\")\nif 'authorized {\n    write \"Error: Unauthorized user\",!\n    quit\n}\n\nset refCheck = ##class(Data.Checks).CheckReferences(^PersonI(\"Name\", last, first, id))\nif 'refCheck {\n    write \"Error: Deleting this node would result in data inconsistencies\",!\n    quit\n}\n\nkill ^PersonI(\"Name\", last, first, id)\n```\n\nIn this example, the `IsAuthorizedRole` method is used to check if the current user has the \"Admin\" role. If not, an error message is displayed and the script is terminated. Next, the `CheckReferences` method is used to verify that deleting the specified node will not result in orphaned references or data inconsistencies. If it would, an error message is displayed and the script is terminated. Only if both checks pass is the node deleted.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP: Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [OWASP: Data Validation](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)\n- [CWE: Missing Authorization](https://cwe.mitre.org/data/definitions/862.html)\n- [CWE: Inconsistent Database State](https://cwe.mitre.org/data/definitions/91.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution for dealing with access control issues."
              },
              "properties": {
                "cwe": [],
                "severity": "MEDIUM",
                "kind": "FAIL"
              }
            },
            {
              "id": "80e5bcc0-bd1f-325f-881b-f661c4d44193",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the deletion of a global node in the ObjectScript programming language without proper authorization verification and referential/index consistency maintenance. In the provided code snippet, a `PersonI` node is being deleted based on a phone number without any checks for user permissions or the integrity of the data structure.\n\nThis can lead to unauthorized data manipulation or deletion, and can also cause inconsistencies in the data structure if the node being deleted is referenced elsewhere in the code. This can potentially lead to data corruption, application crashes, or unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before performing any data manipulation operations. This ensures that only authorized users can delete nodes. \n\nIn addition, it is important to maintain referential integrity when deleting nodes. This means checking if the node being deleted is referenced elsewhere in the code, and updating those references accordingly to prevent data inconsistencies.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nset phone = $zstrip(phone,\"<>P,AL\") ; strip non-alphanumeric characters\nif '$data(^PersonI(\"Phone\", phone)) {\n    write \"Phone number not found\",!\n    quit\n}\nif '##class(Security.App).CheckPermission(\"Delete Person\") {\n    write \"You do not have permission to delete this person\",!\n    quit\n}\nkill ^PersonI(\"Phone\", phone)\n```\n\nIn this fix, we first sanitize the input to prevent injection attacks. Then, we check if the phone number exists in the database. If it doesn't, we output an error message and quit the operation. \n\nNext, we check if the current user has the permission to delete a person. This is done using a hypothetical `CheckPermission` method in a `Security.App` class, which should be replaced with the actual method used in your application. If the user doesn't have the necessary permission, we output an error message and quit the operation.\n\nFinally, if all checks pass, we delete the person from the database.\n\n## Library Dependencies\n\nThe provided code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution for dealing with access control issues. The source code fix provided above is a secondary measure to further enhance security."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "fee1f6cb-d186-35f7-b69a-6a3cac395fd3",
              "name": "Unrestricted READ Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnrestricted READ vulnerability in ObjectScript allows an attacker to cause a Denial of Service (DoS) via resource exhaustion by providing a large input. This is due to the fact that the `READ` command in ObjectScript does not limit the size of the input it can accept. \n\nIn the provided code snippet:\n\n```objectscript\nread \"(617): \", newphone\n```\n\nThe `READ` command is used to get user input without any restriction on the size of the input.\n\n## Mitigation\n\nTo mitigate this vulnerability, you should enforce input validation and limit the size of the input that can be accepted. This can be done by reading the input into a variable and then checking the length of the input. If the input is larger than the expected size, you can throw an error or discard the input.\n\nHere is a code snippet that demonstrates this:\n\n```objectscript\nread \"(617): \", newphone\nif $length(newphone)>10 {\n    write \"Input is too long. Please enter a valid phone number.\"\n    quit\n}\n```\n\nIn this code, if the length of the input is greater than 10, an error message is displayed and the program exits.\n\n## Library Dependencies\n\nThe provided code snippet does not require any library dependencies to execute properly.\n\n## Links\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\n## Note\n\nWhile the above code mitigates the unrestricted READ vulnerability, it is important to note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution when dealing with access control issues."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "1c63cc4b-0cc5-3298-8eb0-523a47135950",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the deletion of a global node in the ObjectScript programming language without proper authorization verification and referential/index consistency maintenance. In the provided code snippet, a global node `^PersonI(\"DOB\", intdob, id)` is being deleted without any checks for user permissions or the maintenance of referential integrity.\n\nThis could lead to unauthorized data deletion if an attacker gains access to the system, and could also result in data inconsistency if the deleted node has references in other parts of the application.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before allowing the deletion of a global node. This could be achieved by verifying the user's role and permissions before executing the `kill` command.\n\nIn addition, it is important to maintain referential integrity when deleting a node. This could be done by checking for any references to the node in other parts of the application and updating or deleting them as necessary before deleting the node itself.\n\n## Source Code Fix Recommendation\n\n```objectscript\nif $System.Security.Check(\"Delete\", \"PersonI\") {\n    // Check for references and handle them\n    // ...\n    kill ^PersonI(\"DOB\", intdob, id)\n} else {\n    // Handle unauthorized access\n    // ...\n}\n```\n\nIn the above code, `$System.Security.Check(\"Delete\", \"PersonI\")` is used to check if the current user has the \"Delete\" permission for the \"PersonI\" resource. If the user is authorized, the code checks for references, handles them, and then deletes the node. If the user is not authorized, the code handles the unauthorized access appropriately.\n\n## Library Dependencies\n\nThe provided code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Top 10 - 2017: A5-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution for access control issues. The source code fix is a secondary measure to enhance security."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "1796d0d6-cb26-353c-bf29-b10f6a8320b8",
              "name": "\"Vulnerability of Unhandled Errors in Transaction Block without Rollback, Mitigated by Try/Catch with Rollback in Catch\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability of \"Unhandled Errors in Transaction Block without Rollback, Mitigated by Try/Catch with Rollback in Catch\" in ObjectScript programming language refers to the situation where an error occurs within a transaction block, but the transaction is not rolled back. This can lead to inconsistent data states and potential data corruption. \n\nIn the provided code, if an error occurs during the execution of any of the operations within the transaction block, the transaction is still committed, which can lead to data inconsistency.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a try/catch block within the transaction block. In the catch block, the transaction should be rolled back. This ensures that if an error occurs during the execution of the transaction, the changes made within the transaction are not committed, thus maintaining data consistency.\n\n## Source Code Fix Recommendation\n\nHere is the recommended fix for the provided code:\n\n```objectscript\ntstart\ntry {\n  set ^PersonD(id) = newanswers\n  if (newname '= currentname) {\n    // kill old name and add new name to index\n    kill ^PersonI(\"Name\", currentlast, currentfirst, id)\n    set ^PersonI(\"Name\", newlast, newfirst, id) = \"\"\n  }\n  if (newphone '= currentphone) {\n    // kill old phone and add new phone to index\n    kill ^PersonI(\"Phone\", currentphone)\n    set ^PersonI(\"Phone\", newphone) = id\n  }\n  if (newintdob '= currentintdob) {\n    // kill old dob and add new dob to index\n    kill ^PersonI(\"DOB\", currentintdob, id)\n    set ^PersonI(\"DOB\", newintdob, id) = \"\"\n  }\n  tcommit  // commit the transaction\n} catch {\n  trollback  // rollback the transaction in case of an error\n}\n```\n\n## Library Dependencies\n\nThe provided code does not appear to have any library dependencies.\n\n## References\n\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/)\n- [CWE-459: Incomplete Cleanup](https://cwe.mitre.org/data/definitions/459.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution when dealing with access control issues."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-459",
                    "url": "https://cwe.mitre.org/data/definitions/459.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-459"
                ]
              }
            },
            {
              "id": "8ce05a7d-fb70-3819-9558-f376f862e78e",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the deletion of a global node in the ObjectScript programming language without proper authorization verification and referential/index consistency maintenance. In the provided code snippet, a `kill` command is used to delete a `PersonI` node from the global array. This operation is performed without any checks for user authorization or maintenance of referential integrity, which could lead to unauthorized data manipulation or inconsistencies in the data structure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before performing any deletion operation. This can be achieved by verifying the user's role or permissions to ensure they are authorized to delete the node. Additionally, referential integrity should be maintained by checking and updating any references or indexes that point to the deleted node.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nif $System.Security.Check(\"DeletePerson\", \"%Admin\") {\n    // Check if the node exists before deletion\n    if $data(^PersonI(\"Name\", currentlast, currentfirst, id)) {\n        kill ^PersonI(\"Name\", currentlast, currentfirst, id)\n        // Perform any necessary updates to maintain referential integrity\n    } else {\n        // Handle the case where the node does not exist\n    }\n} else {\n    // Handle unauthorized access\n}\n```\n\nIn this code, `$System.Security.Check` is used to verify if the current user has the `DeletePerson` permission in the `%Admin` role. If the user is authorized, the code checks if the node exists before deleting it and performs any necessary updates to maintain referential integrity.\n\n## Library Dependencies\n\nThe provided code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\nPlease note that in addition to the proposed solution in the source code, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "33f20dda-eb54-3410-96f5-2d82070864bf",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the `kill` command in the ObjectScript programming language, which is used to delete a global node. In the provided code snippet, the `kill` command is used to delete a person's date of birth (DOB) from the `^PersonI(\"DOB\")` global node. The vulnerability arises when an unauthorized user is able to execute this command, leading to unauthorized deletion of data. Additionally, the deletion of this node could lead to referential or index inconsistency if other parts of the application are referencing this node.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before executing the `kill` command. This ensures that only authorized users can delete data. Additionally, maintaining referential or index consistency is important. This can be achieved by ensuring that all references to the deleted node are updated or deleted as necessary.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how you can implement authorization checks:\n\n```objectscript\nif $Get(%session.Data(\"authorized\")) {\n    kill ^PersonI(\"DOB\", currentintdob, id)\n} else {\n    write \"Unauthorized action.\"\n}\n```\n\nIn this example, the `kill` command is only executed if the user is authorized. The authorization status is stored in the session data. If the user is not authorized, a message is displayed instead.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## OWASP and CWE Resources\n\n- [OWASP Authorization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that the above links are active and accessible to anonymous users at the time of writing this report.\n\n## Additional Notes\n\nWhile the proposed solution in the source code can help mitigate the vulnerability, it is important to note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "5a8eaf42-0bfb-34db-9b94-e596fca1725d",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the deletion of a global node in the ObjectScript programming language without proper authorization verification and referential/index consistency maintenance. In the provided code snippet, a global node `^PersonI(\"Phone\", currentphone)` is being deleted without any checks for user permissions or the maintenance of referential integrity.\n\nThis could potentially lead to unauthorized data deletion if an attacker gains access to the system, and could also result in data inconsistency if the deleted node has references elsewhere in the application.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before allowing the deletion of any global node. This ensures that only users with the necessary permissions can delete data. \n\nAdditionally, maintaining referential integrity is important to prevent data inconsistency. Before deleting a node, check if it is referenced elsewhere in the application. If it is, handle these references appropriately to maintain data consistency.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how you might implement these checks:\n\n```objectscript\nif $Get(^PersonI(\"Phone\", currentphone)) {\n    if $System.Security.Check(\"Delete\", \"Person\") {\n        // Handle references to this node before deletion\n        // ...\n        kill ^PersonI(\"Phone\", currentphone)\n    } else {\n        write \"Error: Unauthorized user\"\n    }\n} else {\n    write \"Error: Node does not exist\"\n}\n```\n\nIn this example, we first check if the node exists. If it does, we then check if the current user has the \"Delete\" permission for the \"Person\" resource. If the user is authorized, we handle any references to the node before deleting it. If the user is not authorized or the node does not exist, we output an error message.\n\n## Library Dependencies\n\nThe provided code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution for dealing with access control issues. The source code fix provided above is a supplementary measure."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "29b13a5d-59a3-3bdc-bf3b-705753a4df6b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry1.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 1,
                  "endLine": 6,
                  "endColumn": 26,
                  "snippet": {
                    "text": "  read !, \"Name: \" , name"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1eb0a19967bdf3a84b461d73a43ca1d67a24b112574176098cd2c9bc56d8ec1f",
            "glog-pfp-ruleFileCode/v1": "9a56055f23c0da538635528a49f93c4c2289ddec20bf6ba59bf5a8760bbe5f4e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9a56055f23c0da538635528a49f93c4c2289ddec20bf6ba59bf5a8760bbe5f4e"
          },
          "properties": {}
        },
        {
          "ruleId": "435010c9-558e-3363-b9d6-0240e98604bb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 1,
                  "endLine": 15,
                  "endColumn": 25,
                  "snippet": {
                    "text": "  read !, \"Name: \", name"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1588fd68e296aefb65029f3ddd8a6aa0477c00f7d05c9f86e8e3ac695b8f4a04",
            "glog-pfp-ruleFileCode/v1": "c106970a3015e1768d0c46da207f0b746f250550d6e18743983cea2298ec866b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c106970a3015e1768d0c46da207f0b746f250550d6e18743983cea2298ec866b"
          },
          "properties": {}
        },
        {
          "ruleId": "dde36b30-4084-3114-9c88-74272d0a459d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry1.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 1,
                  "endLine": 10,
                  "endColumn": 1,
                  "snippet": {
                    "text": "  read !, \"DOB: \", dob"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "a16517c0f7a1862ad00bed6bab01410c3c653d18c2f71619a8ffc6c248854784",
            "glog-pfp-ruleFileCode/v1": "f18002dcec8b804fc4aff86ddc75b0318e4aa913b880f394fc091504f48d1af0"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f18002dcec8b804fc4aff86ddc75b0318e4aa913b880f394fc091504f48d1af0"
          },
          "properties": {}
        },
        {
          "ruleId": "6262da2e-9f37-3863-8dc3-3638cd990cec",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 1,
                  "endLine": 16,
                  "endColumn": 27,
                  "snippet": {
                    "text": "    read !, \"Name: \", name"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "9bad11ba907b84e489cf678d506f41f68acdefa6390291da1f7097d24c85c46c",
            "glog-pfp-ruleFileCode/v1": "2cb5a0f19c644c9bb07d9db361587a7ff6be5972b3d922a461bbca841cc0af73"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2cb5a0f19c644c9bb07d9db361587a7ff6be5972b3d922a461bbca841cc0af73"
          },
          "properties": {}
        },
        {
          "ruleId": "cafcafb1-54e4-3005-a9fe-3fd052454113",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry1.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 1,
                  "endLine": 8,
                  "endColumn": 27,
                  "snippet": {
                    "text": "  read !, \"Phone: \", phone"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e826f109c4b45f10eee9761c945719176bc6b4aa43aa8b528eecb0f23972e1e9",
            "glog-pfp-ruleFileCode/v1": "4d988c25ff43dbdbaf7a05cd1696f869fd7cba05aa4552c4982d3b4e94de80dd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "4d988c25ff43dbdbaf7a05cd1696f869fd7cba05aa4552c4982d3b4e94de80dd"
          },
          "properties": {}
        },
        {
          "ruleId": "8c7bf338-f401-35aa-a1af-2aed24c41f33",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 1,
                  "endLine": 25,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    read !, \"DOB: \", dob"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "224df029136821d38dde7745e212511370d3e10916dbb514ab1a891c86560d53",
            "glog-pfp-ruleFileCode/v1": "358e268752c700789d7651f0306ed565eccce33246a07c4e8fa33f5041d67a61"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "358e268752c700789d7651f0306ed565eccce33246a07c4e8fa33f5041d67a61"
          },
          "properties": {}
        },
        {
          "ruleId": "b80c2cbe-37b4-3abc-99db-55964d1ec4fd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 1,
                  "endLine": 17,
                  "endColumn": 27,
                  "snippet": {
                    "text": "    read !, \"Name: \", name"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f49417a7dc190c0f7abf0c538d61277b77fc1c8a88c2ebf4ae8d30b05bb63a42",
            "glog-pfp-ruleFileCode/v1": "5b5cfa6852a7d0295b4d387fb248358c8f445610bdcd75f779e1661dc64a3fda"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "5b5cfa6852a7d0295b4d387fb248358c8f445610bdcd75f779e1661dc64a3fda"
          },
          "properties": {}
        },
        {
          "ruleId": "4e6b4276-0f0e-32cd-8208-0994f0e7ce53",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 1,
                  "endLine": 18,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  read !, \"DOB: \", dob"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5751a49c2db36846c77ea9f6320c4c2775bf22601f0d6786d67653555592de83",
            "glog-pfp-ruleFileCode/v1": "f68b5162038558ce480a5a02eef7addf417debda8710a3a71119858aab2e0b0c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f68b5162038558ce480a5a02eef7addf417debda8710a3a71119858aab2e0b0c"
          },
          "properties": {}
        },
        {
          "ruleId": "30f6178e-b133-3574-a907-c0d46fcb113b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 1,
                  "endLine": 26,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    read !, \"DOB: \", dob"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ca7f27c4663cfcde90524673660c7511817675b16742a7dd63720f2d855c8562",
            "glog-pfp-ruleFileCode/v1": "08657a3c8e5aa78f981d69041317eda12aee02fc50a0637d69a3c60d8d92bafc"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "08657a3c8e5aa78f981d69041317eda12aee02fc50a0637d69a3c60d8d92bafc"
          },
          "properties": {}
        },
        {
          "ruleId": "5c60e801-55ef-3dc8-9c74-d3d32c337f6f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 1,
                  "endLine": 21,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    read !, \"Phone (617): \", phone"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2e10c95eac71642a8029c12334f170b2e2fef5b84f0a28beaf69fbe9b3c8236c",
            "glog-pfp-ruleFileCode/v1": "956e54f38193a4d0c7ff8ee26c16d459a80289d5dbb9cb31025c55072064a63d"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "956e54f38193a4d0c7ff8ee26c16d459a80289d5dbb9cb31025c55072064a63d"
          },
          "properties": {}
        },
        {
          "ruleId": "6c9216c5-1199-3e3d-be32-76444508b497",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 1,
                  "endLine": 17,
                  "endColumn": 27,
                  "snippet": {
                    "text": "  read !, \"Phone: \", phone"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f88fed0aa0791482ac2ccafcd80ab66c6fd9df6132b217e52ac397e114e40ec3",
            "glog-pfp-ruleFileCode/v1": "bdb55c573e4c113c915bdee6240a0a5f7481ccdaf9736a6b7f6b9901f2e6ef18"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "bdb55c573e4c113c915bdee6240a0a5f7481ccdaf9736a6b7f6b9901f2e6ef18"
          },
          "properties": {}
        },
        {
          "ruleId": "66c2c5c0-c92b-328a-bb77-0c54a329b0d9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 1,
                  "endLine": 22,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    read !, \"Phone (617): \", phone"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "07fa5304f1b44c00ad3ec1dd1c4bda5b000cc073b0cf6e150ed2bca68afa115f",
            "glog-pfp-ruleFileCode/v1": "316cd8af07a8e24f9c394350831b19c3d0607a22b6b0b35d6cb9e811d7da1160"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "316cd8af07a8e24f9c394350831b19c3d0607a22b6b0b35d6cb9e811d7da1160"
          },
          "properties": {}
        },
        {
          "ruleId": "bf4b8989-114a-35f2-b7a6-e46ab8b15089",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Consider using TSTART/TCOMMIT for consistency when multiple related SETs follow an INCREMENT outside transaction."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 1,
                  "endLine": 110,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n  set id = $increment(^PersonD)  // use $increment to generate a new ID"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "8b24776f23797e5a44e106662418a1549d9214b4c7ac7baeb8a2c6f3ab9e3afd",
            "glog-pfp-ruleFileCode/v1": "135fdad62d87be0a6f530642f119c099171187f5db1c23973e0728a2ad18667c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "135fdad62d87be0a6f530642f119c099171187f5db1c23973e0728a2ad18667c"
          },
          "properties": {}
        },
        {
          "ruleId": "5ec0f754-a889-33c5-965e-aa50f1b6348e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential Race Condition in Data Uniqueness Check with Separate Set Method: Consider Lock During Validate-Store Operation."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 5,
                  "endLine": 56,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    if $data(^PersonI(\"Phone\", phone)) {\n      write !, \"Phone number already in use\"\n      return 0"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "d9ffcb402aaefee9aafdeb7fbd1e0302b89f01ce1dc7e0ae4d276782c216d4ae",
            "glog-pfp-ruleFileCode/v1": "3380a87a09c4db7b2f36452d037308798a281171de8ab560de6475418f15d5dd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3380a87a09c4db7b2f36452d037308798a281171de8ab560de6475418f15d5dd"
          },
          "properties": {}
        },
        {
          "ruleId": "472c15e6-ffcc-3a94-8295-65e61fb52e2d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Data Reset Pattern Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 1,
                  "endLine": 137,
                  "endColumn": 9,
                  "snippet": {
                    "text": "ClassMethod Load()\n{\n  kill ^PersonD, ^PersonI"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e46d2a30aa0d31f66fc3c4492caeab96a9e23b5f5e3d2441fd797183e8a8944b",
            "glog-pfp-ruleFileCode/v1": "2c9e244929f3b8095ba97e90535f6a3b94412ed8b8caf76810149bf00d84ef9f"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2c9e244929f3b8095ba97e90535f6a3b94412ed8b8caf76810149bf00d84ef9f"
          },
          "properties": {}
        },
        {
          "ruleId": "b7d2889e-cb47-33e2-86e2-13bf33b98386",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Vulnerability of Unhandled Errors in Transaction Block without Rollback Mechanism\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 3,
                  "endLine": 130,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  tstart\n  set ^PersonD(id) = answers  // store the answers\n\n  set $listbuild(name, phone, intdob) = answers\n  // split name into last and first for storage in index\n  set last = $piece(name, \",\", 1), first = $piece(name, \",\", 2)\n\n\t/* the next three statements store data in subscripts.\n  because of the automatic sorting of subscripts,\n  this has the effect of building 3 indices: name, phone, and DOB */\n  set ^PersonI(\"Name\", last, first, id) = \"\"  // index last and first name\n  set ^PersonI(\"Phone\", phone) = id           // index the UNIQUE phone\n  set ^PersonI(\"DOB\", intdob, id) = \"\"        // index the internal DOB\n\n\t/* these statements turn the id into a \"chunk #\" and a \"position #\"\n  and set a bit into the bitmap index */\n  set chunk = (id\\64000) + 1, position = (id#64000) + 1\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 1\n  tcommit"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5b7be2c20a33b3d2a258344cb731f430ec11b3ddbc054b69dab7828a318fe75c",
            "glog-pfp-ruleFileCode/v1": "8205c180161f40bf01a292183503ab96dd94245da5f906dd4b394539173317d8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8205c180161f40bf01a292183503ab96dd94245da5f906dd4b394539173317d8"
          },
          "properties": {}
        },
        {
          "ruleId": "01879d89-0731-3f2d-8f28-222b8397169c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Global Root Deletion: Admin-Only Access, Not for Production Use\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 137,
                  "startColumn": 1,
                  "endLine": 137,
                  "endColumn": 26,
                  "snippet": {
                    "text": "  kill ^PersonD, ^PersonI"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f7acc2d8fb698b79dbe5f1419cfb25ea127a904bf8965d4259905f2cd4f7f53e",
            "glog-pfp-ruleFileCode/v1": "71bf54ba2a9144e1b91e28200b017cdf95ff6c26b1370006bc6cd7ee99d51ff9"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "71bf54ba2a9144e1b91e28200b017cdf95ff6c26b1370006bc6cd7ee99d51ff9"
          },
          "properties": {}
        },
        {
          "ruleId": "d17c8905-6da2-3b73-999c-52a5bdb2dac6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup1.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 1,
                  "endLine": 16,
                  "endColumn": 29,
                  "snippet": {
                    "text": "  read !, \"Lookup: \", lookup"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "0c5b9af17a28ed0b9279a1e9712f6f38679bf5f41b80f650a766f87328eb37fd",
            "glog-pfp-ruleFileCode/v1": "c33c4c317a05b68054c674ce6f676005e03c1e1686683aa3d6857aa60af2ae70"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c33c4c317a05b68054c674ce6f676005e03c1e1686683aa3d6857aa60af2ae70"
          },
          "properties": {}
        },
        {
          "ruleId": "1cb1c287-fdbb-3c33-bc9c-8e1f9d21e47d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 1,
                  "endLine": 20,
                  "endColumn": 29,
                  "snippet": {
                    "text": "  read !, \"Lookup: \", lookup"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f24685b161882f1465ed505a495515fa27940d8def5b101faf6308955e1af3c2",
            "glog-pfp-ruleFileCode/v1": "9756fec061ff302a1cc18b3403008ea998700df285977b6c494c7b160b96b69a"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9756fec061ff302a1cc18b3403008ea998700df285977b6c494c7b160b96b69a"
          },
          "properties": {}
        },
        {
          "ruleId": "635e5a72-f3de-3630-bcf8-61e15f68ecc9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 1,
                  "endLine": 20,
                  "endColumn": 29,
                  "snippet": {
                    "text": "  read !, \"Lookup: \", lookup"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "9abcd07a0ca8b7ce5e8045950c2d196b71f9130798bf83870b865ba023b7870a",
            "glog-pfp-ruleFileCode/v1": "ee8a078d79a282cfd533a335d81e90d8b573449c2f864eeaacc0b0ae86e092e3"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ee8a078d79a282cfd533a335d81e90d8b573449c2f864eeaacc0b0ae86e092e3"
          },
          "properties": {}
        },
        {
          "ruleId": "4d0c456f-a42e-311e-b69e-14311e702bb7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Admin-Only Restriction Required for Detected Extent Deletion Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 35,
                  "endLine": 138,
                  "endColumn": 47,
                  "snippet": {
                    "text": "  do ##class(ObjectScript.Person).%KillExtent()"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "85887d486731a3fbc39cb1daf9906e7d01cc348c959a812be3eef71a9837b677",
            "glog-pfp-ruleFileCode/v1": "4490d8d8e00d0a76642c1ef08ef845f36dc24664bbc7b8c452933a22ce1968a3"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "4490d8d8e00d0a76642c1ef08ef845f36dc24664bbc7b8c452933a22ce1968a3"
          },
          "properties": {}
        },
        {
          "ruleId": "29ee34b7-ccf0-30dd-b66b-6f7bc6735d1b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Unprotected Transaction Block Vulnerability with Error Handling via Try/Catch and TROLLBACK\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 226,
                  "startColumn": 3,
                  "endLine": 232,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  tstart\n  kill ^PersonD(id)\n  kill ^PersonI(\"Name\", last, first, id)\n  kill ^PersonI(\"Phone\", phone)\n  kill ^PersonI(\"DOB\", intdob, id)\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 0\n  tcommit"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "524a8872c2c71713c7d233796ce2436aa88e403eae222244eba769be399d226c",
            "glog-pfp-ruleFileCode/v1": "6d4ad56227d20f25898055bfda0ca64e27ba177955c1efc72131748ef0ad1950"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "6d4ad56227d20f25898055bfda0ca64e27ba177955c1efc72131748ef0ad1950"
          },
          "properties": {}
        },
        {
          "ruleId": "72d80781-e079-3971-b3e2-6b71b145a3f1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 227,
                  "startColumn": 1,
                  "endLine": 227,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonD(id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ba0fc87304c8cfdd7a5ae46bbd6732cb705590a374a0af6c559ee98fd900fc06",
            "glog-pfp-ruleFileCode/v1": "fbfa074c25598a93d276a65d1cd8f7625c3162ef0859e7ae8e56ed97364861dd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "fbfa074c25598a93d276a65d1cd8f7625c3162ef0859e7ae8e56ed97364861dd"
          },
          "properties": {}
        },
        {
          "ruleId": "20132af7-7e3c-31be-bd4f-af6dee00c8e0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 228,
                  "startColumn": 1,
                  "endLine": 228,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonI(\"Name\", last, first, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "39ccfa5bfee025a32458dd23f11fa0fbde5a5e84975962b13a6dc5c3c7935ff7",
            "glog-pfp-ruleFileCode/v1": "9cc9bcc620932ba42597e1a6210b9aa47ad40853372fda4cf8a57843ca87c6d3"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9cc9bcc620932ba42597e1a6210b9aa47ad40853372fda4cf8a57843ca87c6d3"
          },
          "properties": {}
        },
        {
          "ruleId": "80e5bcc0-bd1f-325f-881b-f661c4d44193",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 229,
                  "startColumn": 1,
                  "endLine": 229,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonI(\"Phone\", phone)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f6bce1cae137605db71abc33ba5171de8773f03c266f9ae5b8b2571cc8f993c6",
            "glog-pfp-ruleFileCode/v1": "8c64b374d9bba1d82fb6a3e95720ba33c7ba16252397344301bf24bc84a6d6e1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8c64b374d9bba1d82fb6a3e95720ba33c7ba16252397344301bf24bc84a6d6e1"
          },
          "properties": {}
        },
        {
          "ruleId": "fee1f6cb-d186-35f7-b69a-6a3cac395fd3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 271,
                  "startColumn": 1,
                  "endLine": 271,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    read \"(617): \", newphone"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "47569fa8d3b16dd1cfa17e01d4895470223f0d3097fdf646052c77294f39fb34",
            "glog-pfp-ruleFileCode/v1": "79a0c965f5cb0eedc5654dbc0bcd0a4b8e0bf150704e0d3707ac7bf3483a7895"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "79a0c965f5cb0eedc5654dbc0bcd0a4b8e0bf150704e0d3707ac7bf3483a7895"
          },
          "properties": {}
        },
        {
          "ruleId": "1c63cc4b-0cc5-3298-8eb0-523a47135950",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 230,
                  "startColumn": 1,
                  "endLine": 230,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonI(\"DOB\", intdob, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ae317b0b2529d136a98727ca20c860a5f69130866ce7764ab51296235befc3f1",
            "glog-pfp-ruleFileCode/v1": "72280b74bd40d6c1b6730110938a1ed6931199110b9f9e2b968194cfea2c44ce"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "72280b74bd40d6c1b6730110938a1ed6931199110b9f9e2b968194cfea2c44ce"
          },
          "properties": {}
        },
        {
          "ruleId": "1796d0d6-cb26-353c-bf29-b10f6a8320b8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Vulnerability of Unhandled Errors in Transaction Block without Rollback, Mitigated by Try/Catch with Rollback in Catch\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 310,
                  "startColumn": 3,
                  "endLine": 327,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  tstart\n  set ^PersonD(id) = newanswers\n  if (newname '= currentname) {\n    // kill old name and add new name to index\n    kill ^PersonI(\"Name\", currentlast, currentfirst, id)\n    set ^PersonI(\"Name\", newlast, newfirst, id) = \"\"\n  }\n  if (newphone '= currentphone) {\n    // kill old phone and add new phone to index\n    kill ^PersonI(\"Phone\", currentphone)\n    set ^PersonI(\"Phone\", newphone) = id\n  }\n  if (newintdob '= currentintdob) {\n    // kill old dob and add new dob to index\n    kill ^PersonI(\"DOB\", currentintdob, id)\n    set ^PersonI(\"DOB\", newintdob, id) = \"\"\n  }\n  tcommit  // commit the transaction"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "eea00ea157f2529b3bbabc4f5e20dc33d25f70cf3ead49ab062e1d7158728039",
            "glog-pfp-ruleFileCode/v1": "7d97a0da241969d8b6bc1b8ef7d29dc93357400c5eebe15494f8c5338fd2ade8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7d97a0da241969d8b6bc1b8ef7d29dc93357400c5eebe15494f8c5338fd2ade8"
          },
          "properties": {}
        },
        {
          "ruleId": "8ce05a7d-fb70-3819-9558-f376f862e78e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 314,
                  "startColumn": 1,
                  "endLine": 314,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    kill ^PersonI(\"Name\", currentlast, currentfirst, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "549252a2a90c1958ff803d2a3c54e0e499f769457676cd390c226e4576cd765e",
            "glog-pfp-ruleFileCode/v1": "c2e3657171377b6ae29f818e99747196ae676817b036847bda59fb29f8bc456b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c2e3657171377b6ae29f818e99747196ae676817b036847bda59fb29f8bc456b"
          },
          "properties": {}
        },
        {
          "ruleId": "33f20dda-eb54-3410-96f5-2d82070864bf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 1,
                  "endLine": 324,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    kill ^PersonI(\"DOB\", currentintdob, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "080f2e69363b80969258314e19cf7dcee5d1c69c12150f348c143c8f7601d902",
            "glog-pfp-ruleFileCode/v1": "0418632810a07515c059cac234c6be7ec2cb747aae142d87bf017991cf6a047f"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0418632810a07515c059cac234c6be7ec2cb747aae142d87bf017991cf6a047f"
          },
          "properties": {}
        },
        {
          "ruleId": "5a8eaf42-0bfb-34db-9b94-e596fca1725d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 319,
                  "startColumn": 1,
                  "endLine": 319,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    kill ^PersonI(\"Phone\", currentphone)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "811ecacde85f4a18d3a70ef32bdb6c98ef22c90eafe44b1a2361d821cbcfed55",
            "glog-pfp-ruleFileCode/v1": "08d790c5f05b94539a31cab33d359f9a0a2e5984fb4fc75e29a9a8a43d1419eb"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "08d790c5f05b94539a31cab33d359f9a0a2e5984fb4fc75e29a9a8a43d1419eb"
          },
          "properties": {}
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}