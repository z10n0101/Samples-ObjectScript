{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "dde36b30-4084-3114-9c88-74272d0a459d",
              "name": "Unrestricted READ Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn the InterSystems ObjectScript programming language, the unrestricted READ length or lack of input validation vulnerability occurs when the program does not validate or improperly validates input from an upstream component. This can lead to the program reading in more data than it can handle, leading to resource exhaustion or denial of service (DoS) attacks. \n\nIn the provided code snippet, the `read !, \"DOB: \", dob` command reads an input from the user without any restrictions on the length of the input. This can potentially allow an attacker to supply very large input, causing the program to consume excessive resources and potentially leading to a DoS condition.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the length of the input that can be read by the program. This can be achieved by using the `read` command with a specified length limit, and then validating the input to ensure it meets the required format and length.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nread !, \"DOB: \", dob\nif $length(dob)>10 {\n    write \"Input too long. Please enter a valid DOB.\"\n    quit\n}\nif dob'?1(1.2N1\"/\"1.2N1\"/\"4N) {\n    write \"Invalid format. Please enter DOB in MM/DD/YYYY format.\"\n    quit\n}\n```\n\nThis code first reads the input from the user, then checks if the length of the input is greater than 10 (the length of a date in MM/DD/YYYY format). If the input is too long, the program outputs an error message and quits. If the input is of the correct length, the program then checks if the input matches the required format (MM/DD/YYYY). If the input does not match this format, the program outputs an error message and quits.\n\nNote: In addition to the above code-level mitigation, it is also recommended to enforce authorization using IRIS security (resources/roles) and/or application authentication as a primary solution.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-20"
                ]
              }
            },
            {
              "id": "435010c9-558e-3363-b9d6-0240e98604bb",
              "name": "Unlimited Length and Lack of Validation in READ Function Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability is related to the `READ` function in ObjectScript programming language which is used to read input from the user. The `READ` function in the provided code does not limit the length of the input, which can lead to resource exhaustion or denial of service if an attacker supplies a very large input. This is especially concerning if the application is network-exposed. \n\nAdditionally, the `READ` function does not validate the input, which can lead to other types of attacks if the input is used in a security-sensitive context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input and to validate the input to ensure it meets the expected format and content. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```objectscript\nread !, \"Name: \", name\nset name=$extract(name,1,255) ; limit length to 255 characters\nif name'?1A.E write \"Invalid input\",! quit  ; validate input\n```\n\nThis code limits the length of the input to 255 characters and validates that the input consists of alphabetic characters only. If the input is invalid, an error message is displayed and the program quits.\n\n## Library Dependencies\n\nThe provided code does not require any library dependencies to execute properly.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017 Category A3: Sensitive Data Exposure](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)\n\nNote: All links were tested and are active as of the time of writing this report.\n\n## Additional Note\n\nWhile the above code fix recommendation mitigates the specific vulnerability in the code, it is important to note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution for access control issues. This includes checking user roles for authorization using `$SYSTEM.Security.Check()` in ObjectScript, implementing environment safeguards, and maintaining proper logging/auditing."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  },
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400",
                  "CWE-20"
                ]
              }
            },
            {
              "id": "4e6b4276-0f0e-32cd-8208-0994f0e7ce53",
              "name": "Unrestricted READ Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn the InterSystems ObjectScript programming language, the unrestricted READ length or lack of input validation vulnerability occurs when the program does not validate or improperly validates input from an upstream component. This can lead to the program reading in more data than it can handle, leading to resource exhaustion or denial of service (DoS) attacks. \n\nIn the provided code snippet, the `read !, \"DOB: \", dob` command reads an input from the user without any restrictions on the length of the input. This can potentially allow an attacker to supply very large input, causing the program to consume excessive resources and potentially leading to a DoS condition.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the length of the input that can be read by the program. This can be achieved by using the `read` command with a specified length limit, and then validating the input to ensure it meets the required format and length.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nread !, \"DOB: \", dob\nif $length(dob)>10 {\n    write \"Input too long. Please enter a valid DOB.\"\n    quit\n}\nif dob'?1(1.2N1\"/\"1.2N1\"/\"4N) {\n    write \"Invalid format. Please enter DOB in MM/DD/YYYY format.\"\n    quit\n}\n```\n\nThis code first reads the input from the user, then checks if the length of the input is greater than 10 (the length of a date in MM/DD/YYYY format). If the input is too long, the program outputs an error message and quits. If the input is of the correct length, the program then checks if the input matches the required format (MM/DD/YYYY). If the input does not match this format, the program outputs an error message and quits.\n\nNote: In addition to the above code-level mitigation, it is also recommended to enforce authorization using IRIS security (resources/roles) and/or application authentication as a primary solution.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-20"
                ]
              }
            },
            {
              "id": "cafcafb1-54e4-3005-a9fe-3fd052454113",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn the InterSystems ObjectScript programming language, the `read` command is used to get input from the user. If the length of the input is not restricted or validated, it can lead to a vulnerability known as Unrestricted Read Length or Lack of Input Validation. This vulnerability can be exploited by an attacker to cause a Denial of Service (DoS) attack by providing a very large input, which can exhaust the system resources (memory/CPU).\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input length limits and validation after the `read` command. This can be done by checking the length of the input and validating it against a set of allowed characters or patterns. If the input is not valid, the program should reject it and ask the user to enter a valid input.\n\n## Source Code Fix Recommendation\n\nHere is a code snippet that demonstrates how to enforce input length limits and validation in ObjectScript:\n\n```objectscript\nread !, \"Phone: \", phone\nif $length(phone) > 15 || $length(phone) < 10 {\n    write !, \"Invalid input. Please enter a valid phone number.\"\n    quit\n}\nif '($match(phone, \"^[0-9]*$\")) {\n    write !, \"Invalid input. Please enter a valid phone number.\"\n    quit\n}\n```\n\nIn this code, the length of the phone number is checked to be between 10 and 15 characters. The phone number is also validated to contain only numeric characters. If the input is not valid, an error message is displayed and the program exits.\n\nNote: Beside proposed solution in the source code, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be primary solution. This can be achieved by using `$SYSTEM.Security.Check()` for resource/privilege check, along with environment safeguards and real logging/auditing.\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-20"
                ]
              }
            },
            {
              "id": "6c9216c5-1199-3e3d-be32-76444508b497",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn the InterSystems ObjectScript programming language, the `read` command is used to get input from the user. If the length of the input is not restricted or validated, it can lead to a vulnerability known as Unrestricted Read Length or Lack of Input Validation. This vulnerability can be exploited by an attacker to cause a Denial of Service (DoS) attack by providing a very large input, which can exhaust the system resources (memory/CPU).\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input length limits and validation after the `read` command. This can be done by checking the length of the input and validating it against a set of allowed characters or patterns. If the input is not valid, the program should reject it and ask the user to enter a valid input.\n\n## Source Code Fix Recommendation\n\nHere is a code snippet that demonstrates how to enforce input length limits and validation in ObjectScript:\n\n```objectscript\nread !, \"Phone: \", phone\nif $length(phone) > 15 || $length(phone) < 10 {\n    write !, \"Invalid input. Please enter a valid phone number.\"\n    quit\n}\nif '($match(phone, \"^[0-9]*$\")) {\n    write !, \"Invalid input. Please enter a valid phone number.\"\n    quit\n}\n```\n\nIn this code, the length of the phone number is checked to be between 10 and 15 characters. The phone number is also validated to contain only numeric characters. If the input is not valid, an error message is displayed and the program exits.\n\nNote: Beside proposed solution in the source code, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be primary solution. This can be achieved by using `$SYSTEM.Security.Check()` for resource/privilege check, along with environment safeguards and real logging/auditing.\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## References\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-20"
                ]
              }
            },
            {
              "id": "cd5c0c9e-441e-3ab5-ae94-990b4540352a",
              "name": "\"READ Vulnerability: No Length Limit and Lacks Downstream Validation - Suggest Adding #maxlen for Enhanced Security\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `READ` command in the ObjectScript programming language. The `READ` command is used to get input from the user. In the provided code snippet, there is no limit on the length of the input that can be provided by the user. This can lead to resource exhaustion or denial of service (DoS) if an attacker provides a very large input. Additionally, the input is not validated downstream, which can lead to further security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input and to validate the input downstream. This can be done by checking the length of the input string and returning an error if it exceeds a certain limit. Additionally, the input should be validated to ensure it meets certain criteria (e.g., it does not contain special characters, it is not a reserved word, etc.).\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\ndo {\n    read !, \"Name: \", name\n    if $LENGTH(name) > 50 { // limit input length to 50 characters\n        write !, \"Error: Name is too long. Please enter a name with 50 characters or less.\"\n        return 0\n    }\n    if '..ValidName(name) {\n        write !, \"Error: Invalid name. Please enter a valid name.\"\n        return 0\n    }\n    return:(name = \"\") 0  // user entered nothing so return FALSE, exit loop AND method\n} while 1\n```\n\nIn addition to the above code-level mitigation, it is also recommended to enforce authorization using IRIS security (resources/roles) and/or application authentication. This can be done using the `$SYSTEM.Security.Check()` method in ObjectScript.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## OWASP and CWE Resources\n\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "3ed646f7-709c-3f10-a7ac-befa9871452f",
              "name": "\"READ lacks length limit and downstream validation, consider implementing #maxlen for enhanced security.\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the lack of a length limit and downstream validation in the `READ` command in the ObjectScript programming language. This can potentially lead to resource exhaustion or denial of service (DoS) attacks if an attacker is able to supply very large input, especially in a network-exposed UI/API. \n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce limits and validation after the `READ` command. This can be done by checking the length of the input and validating it before proceeding with further operations. \n\nIn addition, it is crucial to enforce authorization using IRIS security (resources/roles) and/or application authentication. This should be the primary solution for dealing with access control issues. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```objectscript\ndo {\n    read !, \"DOB: \", dob\n    if $LENGTH(dob) > MAX_LENGTH {\n        write !, \"Input exceeds maximum length.\"\n        quit\n    }\n    if '..ValidDOB(dob, .intdob) {\n        // proceed with operations\n    } else {\n        write !, \"Invalid DOB.\"\n    }\n} while 1\n```\n\nIn this fix, `MAX_LENGTH` should be replaced with the maximum allowed length for the `dob` input. \n\nAlso, it is recommended to check user roles for authorization using `$SYSTEM.Security.Check()`. \n\n```objectscript\nset status = $SYSTEM.Security.Check(\"resource-name\", \"privilege-name\")\nif 'status {\n    write \"Access denied.\"\n    quit\n}\n```\n\nReplace `\"resource-name\"` and `\"privilege-name\"` with the appropriate resource and privilege names.\n\n## Library Dependencies\n\nThe code example does not appear to require any specific library dependencies to execute properly.\n\n## OWASP and CWE Resources\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "29b13a5d-59a3-3bdc-bf3b-705753a4df6b",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn the InterSystems ObjectScript programming language, the `read` command is used to get input from the user. If the length of the input is not restricted or validated, it can lead to a vulnerability known as Unrestricted Read Length or Lack of Input Validation. This vulnerability can be exploited by an attacker to cause a Denial of Service (DoS) attack by providing a very large input, which can exhaust the system resources (memory/CPU).\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input length limits and validation after the `read` command. This can be done by checking the length of the input and validating it against a predefined acceptable range. If the input is not within the acceptable range, the program should reject it and ask for a new input.\n\n## Source Code Fix Recommendation\n\nHere is a code snippet that demonstrates how to enforce input length limits and validation:\n\n```objectscript\nread !, \"Name: \" , name\nif $length(name) > 100 {\n    write !, \"Input is too long. Please enter a name up to 100 characters.\"\n    quit 0\n}\nif $length(name) < 1 {\n    write !, \"Input is too short. Please enter a name.\"\n    quit 0\n}\n```\n\nIn this code, the length of the input `name` is checked after it is read. If the length is more than 100 characters or less than 1 character, the program writes an error message and quits with a return value of 0.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript.\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## OWASP and CWE Resources\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)\n\nPlease note that these links are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-20"
                ]
              }
            },
            {
              "id": "42493282-59f2-325f-a414-89b76af33cf1",
              "name": "\"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `READ` command in ObjectScript, which lacks a length limit. This can potentially lead to resource exhaustion or denial of service (DoS) attacks if an attacker is able to supply very large input. The `READ` command is used to read input from the user, and without a length limit, it can consume excessive memory and CPU resources. \n\nIn addition, the code lacks downstream validation for the input read by the `READ` command. This means that the input is not checked for validity before it is used in the program, which can lead to unexpected behavior or security vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input read by the `READ` command. This can be done by reading the input into a variable and then checking the length of the variable. If the length exceeds a certain limit, the program should reject the input and ask the user to enter it again.\n\nIn addition, it is important to perform downstream validation on the input. This means checking the input for validity before it is used in the program. This can include checks for data type, format, and range, among others.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```objectscript\ndo {\n    read !, \"Name: \", name\n    if $LENGTH(name) > 100 {\n        write !, \"Name is too long. Please enter a name with 100 characters or less.\"\n        continue\n    }\n    return:(name = \"\") 0  // user entered nothing so return FALSE, exit loop AND method\n} While '..ValidName(name)\n```\n\nIn this fix, the length of the input is checked after it is read. If the length exceeds 100 characters, the program rejects the input and asks the user to enter it again. The `ValidName` method should also be implemented to perform downstream validation on the input.\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\n## Note\n\nIn addition to the source code fix, it is important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This can be done using the `$SYSTEM.Security.Check()` method in ObjectScript. This should be the primary solution for dealing with access control issues."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "54211a2f-95e9-3e07-897e-253a1bd9dc64",
              "name": "\"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `READ` command in the ObjectScript programming language. The `READ` command lacks a length limit, which means that it can accept an unlimited amount of input. This can potentially lead to resource exhaustion or denial of service (DoS) attacks if an attacker is able to supply a very large input. Additionally, the `READ` command requires downstream validation, which means that the input must be validated after it is read. If the validation is not properly implemented, it can lead to security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce limits and validation on the input after it is read. This can be done by checking the length of the input and validating it before processing it further. Additionally, it is important to implement proper error handling to ensure that the application can gracefully handle invalid inputs.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```objectscript\ndo {\n    read !, \"Phone (617): \", phone\n    if $length(phone) > 10 {\n        write !, \"Phone number is too long. Please enter a valid phone number.\"\n        continue\n    }\n    if '..ValidPhone(.phone) {\n        break\n    } else {\n        write !, \"Invalid phone number. Please try again.\"\n    }\n} While 1\n```\n\nIn this fix, the length of the phone number is checked after it is read. If the phone number is too long, an error message is displayed and the loop continues. If the phone number is valid, the loop breaks.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution for access control issues. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript.\n\n## Library Dependencies\n\nThe code example does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP Top 10 - A1 Injection](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "a812b057-eba4-3975-85d0-6cb81435013b",
              "name": "\"READ Vulnerability: No Length Limit and Lacks Downstream Validation, Suggests Adding #maxlen for Enhanced Security\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the `READ` command in the ObjectScript programming language. The `READ` command is used to get input from the user. In the provided code snippet, there is no limit on the length of the input that can be provided by the user. This can lead to resource exhaustion or denial of service (DoS) if an attacker provides a very large input. Additionally, the input is not validated downstream, which can lead to further security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input and to validate the input downstream. In ObjectScript, the `#` symbol can be used to specify a fixed number of characters to read. However, this is not a great solution in this case as it means reading exactly \"number\" characters, not “up to number”. Any extra characters the user typed can remain in the input buffer and be consumed by subsequent `READ`s, which can cause confusing behavior. A better solution would be to keep the normal line `READ`, then enforce limits/validation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\ndo {\n    read !, \"Phone (617): \", phone\n    if $LENGTH(phone) > 10 {\n        write !, \"Phone number is too long. Please enter a valid phone number.\"\n        continue\n    }\n    if '..ValidPhone(.phone) {\n        break\n    } else {\n        write !, \"Invalid phone number. Please try again.\"\n    }\n} while 1\n```\n\nIn this fix, the length of the phone number is checked after it is read. If the length is more than 10 characters, an error message is displayed and the loop continues. The phone number is also validated using the `ValidPhone` method. If the phone number is not valid, an error message is displayed and the loop continues. If the phone number is valid, the loop breaks.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This can be done using the `$SYSTEM.Security.Check()` method in ObjectScript.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-20"
                ]
              }
            },
            {
              "id": "499a80f3-9d51-308a-a8b7-d54e1e77d26a",
              "name": "\"READ Vulnerability: No Length Limit and Lacks Downstream Validation - Suggest Adding #maxlen for Enhanced Security\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `READ` command in the ObjectScript programming language. The `READ` command is used to get input from the user. In the provided code snippet, there is no limit on the length of the input that can be provided by the user. This can lead to resource exhaustion or denial of service (DoS) if an attacker provides a very large input. Additionally, the input is not validated downstream, which can lead to further security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input and to validate the input downstream. This can be done by checking the length of the input string and ensuring it is within acceptable limits, and by validating the input to ensure it meets certain criteria (e.g., it is a valid date of birth).\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\ndo {\n    read !, \"DOB: \", dob\n    if $LENGTH(dob) > 10 {\n        write !, \"Input too long. Please enter a valid DOB.\"\n        continue\n    }\n    if '..ValidDOB(dob, .intdob) {\n        break\n    } else {\n        write !, \"Invalid DOB. Please try again.\"\n    }\n} While 1\n```\n\nIn this fix, the length of the input is checked and if it is greater than 10 characters, an error message is displayed and the loop continues. The input is also validated using the `ValidDOB` method and if it is not valid, an error message is displayed and the loop continues.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution for access control issues. This can be done using the `$SYSTEM.Security.Check()` method in ObjectScript.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-20"
                ]
              }
            },
            {
              "id": "5ec0f754-a889-33c5-965e-aa50f1b6348e",
              "name": "Potential race condition in uniqueness check with separate SET method: consider using LOCK for validate-store operation.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe code snippet provided is vulnerable to a race condition during the check for uniqueness of a phone number in the `^PersonI(\"Phone\", phone)` global. A race condition occurs when the behavior of a system depends on the relative timing of events, such as the ordering of read and write operations. In this case, the vulnerability arises because the check for uniqueness and the subsequent set operation are not atomic, meaning that another process could potentially insert the same phone number between the time it is checked for uniqueness and the time it is set, leading to a violation of the intended uniqueness constraint.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should ensure that the check for uniqueness and the subsequent set operation are performed atomically. This can be achieved by using a lock to synchronize access to the `^PersonI(\"Phone\", phone)` global. The lock should be acquired before the check for uniqueness and released after the set operation. This will ensure that no other process can insert the same phone number between the check and the set.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code snippet:\n\n```objectscript\nlock +^PersonI(\"Phone\", phone):10\nif $data(^PersonI(\"Phone\", phone)) {\n    write !, \"Phone number already in use\"\n    lock -^PersonI(\"Phone\", phone)\n    return 0\n}\n// Set operation here\nlock -^PersonI(\"Phone\", phone)\n```\n\nIn this fix, the `lock +^PersonI(\"Phone\", phone):10` command acquires a lock on the `^PersonI(\"Phone\", phone)` global with a timeout of 10 seconds. If the lock cannot be acquired within this time, the command will fail. The `lock -^PersonI(\"Phone\", phone)` command releases the lock.\n\nNote: Always ensure that proper authorization is enforced using IRIS security (resources/roles) and/or application authentication. This should be the primary solution for access control issues. In addition to the source code fix, you should also check user roles for authorization using `$SYSTEM.Security.Check()` plus environment safeguards and real logging/auditing.\n\n## Library Dependencies\n\nThe code snippet does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-362"
                ]
              }
            },
            {
              "id": "01879d89-0731-3f2d-8f28-222b8397169c",
              "name": "\"Global Root Deletion: Admin-Only Access, Not for Production Use\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"Global Root Deletion: Admin-Only Access, Not for Production Use\" in ObjectScript programming language refers to the situation where the `kill` command is used without proper access control. This command is used to delete global variables, in this case `^PersonD` and `^PersonI`. If an unauthorized user gains access to this command, it can lead to data loss or corruption.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper access control mechanisms. This can be achieved by checking the user's role before executing the `kill` command. Only users with the appropriate privileges should be allowed to execute such commands. \n\n## Source Code Fix Recommendation\n\nHere is a sample code fix that checks if the user has the 'Admin' role before executing the `kill` command:\n\n```objectscript\nif $SYSTEM.Security.Check(\"Admin\", \"%Admin_Manage\") {\n    kill ^PersonD, ^PersonI\n} else {\n    write \"Insufficient privileges to perform this operation.\",!\n    return 0\n}\n```\n\nIn addition to the above code-level fix, it is also recommended to enforce authorization using IRIS security (resources/roles) and/or application authentication. This should be the primary solution for dealing with access control issues.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Resources\n\n- [OWASP Top 10-2017 A5-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that the above links are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "472c15e6-ffcc-3a94-8295-65e61fb52e2d",
              "name": "\"Data Reset Pattern Vulnerability\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Data Reset Pattern Vulnerability\" in ObjectScript refers to the situation where an application resets or deletes data in a global variable without proper authorization checks. This can lead to unauthorized data manipulation or deletion, which can have serious implications for the integrity and availability of the application's data.\n\nIn the provided code snippet, the `kill` command is used to delete all data in the `^PersonD` and `^PersonI` global variables. If an attacker can invoke this method without proper authorization, they can delete all data in these variables.\n\n## Mitigation\n\nTo mitigate this vulnerability, it is crucial to implement proper access control checks before performing sensitive operations such as data deletion. This can be achieved by using the `$SYSTEM.Security.Check()` method to verify if the current user has the necessary privileges to perform the operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nClassMethod Load()\n{\n    // Check if the current user has the necessary privileges\n    set status = $SYSTEM.Security.Check(\"PrivilegeName\", \"%DB_USER\")\n    if 'status {\n        // If the user does not have the necessary privileges, return an error\n        write \"You do not have the necessary privileges to perform this operation.\",!\n        return 0\n    }\n    \n    // If the user has the necessary privileges, proceed with the data deletion\n    kill ^PersonD, ^PersonI\n}\n```\n\nIn this fix, the `PrivilegeName` should be replaced with the actual name of the privilege that is required to delete data in the `^PersonD` and `^PersonI` global variables.\n\nPlease note that this code fix should be used in conjunction with other security measures such as enforcing authorization using IRIS security (resources/roles) and/or application authentication.\n\n## References\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "bf4b8989-114a-35f2-b7a6-e46ab8b15089",
              "name": "Consider using TSTART/TCOMMIT for consistency when multiple related SETs follow $INCREMENT outside transaction.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn InterSystems ObjectScript, the `$increment` function is used to atomically increment a global or local variable. However, when multiple related `SET` operations follow `$increment` outside a transaction, it can lead to inconsistencies. This is because if an error occurs during one of the `SET` operations, the previous operations are not rolled back, leading to a state where some operations have been executed and others have not.\n\nThis vulnerability is related to the Atomicity property of ACID (Atomicity, Consistency, Isolation, Durability) in database transactions. Atomicity requires that operations within a transaction are either all completed successfully or none are completed (i.e., if an error occurs during a transaction, all operations are rolled back).\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use `TSTART` and `TCOMMIT` commands to ensure atomicity. `TSTART` begins a transaction and `TCOMMIT` commits the transaction. If an error occurs during the transaction, you can use `TROLLBACK` to roll back the transaction.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```objectscript\nTSTART\nset id = $increment(^PersonD)  // use $increment to generate a new ID\n// other related SET operations\nif $TLEVEL { TCOMMIT }\n```\n\nIn this code, `TSTART` begins a transaction. The `SET` operations are then executed. If the transaction level (`$TLEVEL`) is greater than 0, indicating that a transaction has been started, `TCOMMIT` is used to commit the transaction.\n\n## Library Dependencies\n\nThe provided code does not require any library dependencies to execute properly.\n\n## Links\n\n- [OWASP - Insecure Direct Object References](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This should be in addition to the proposed source code fix. In the source code fix recommendation, always use ObjectScript resource/privilege check via `$SYSTEM.Security.Check()` plus environment safeguards and real logging/auditing."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-362"
                ]
              }
            },
            {
              "id": "4d0c456f-a42e-311e-b69e-14311e702bb7",
              "name": "\"Admin-Only Restriction Required for Detected Extent Deletion Vulnerability\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"Admin-Only Restriction Required for Detected Extent Deletion Vulnerability\" in ObjectScript programming language refers to the lack of proper access control restrictions in the code. The code snippet `do ##class(ObjectScript.Person).%KillExtent()` is a method that deletes all data from the extent of a class. If this method is accessible to non-admin users, it can lead to unauthorized data deletion, which is a serious security issue.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper access control checks before executing sensitive operations such as data deletion. This can be achieved by checking the user's role and ensuring that only users with admin privileges can execute the method. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```objectscript\nset userRole = $SYSTEM.Security.LoginUserRole(\"_SYSTEM\")\nif userRole '= \"Admin\" {\n    write \"Unauthorized access. Only admins can delete data.\",!\n    return 0\n}\ndo ##class(ObjectScript.Person).%KillExtent()\n```\n\nIn the above code, we first get the role of the logged-in user. If the user is not an admin, we display an error message and exit the function. If the user is an admin, we proceed to delete the data.\n\n**Note:** This code fix is a secondary measure. The primary solution should be enforcing authorization using IRIS security (resources/roles) and/or application authentication.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies to execute properly.\n\n## References\n\n- [OWASP Access Control Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that the links provided are active and accessible to anonymous users."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "1f4724ef-1c72-3b83-aac4-2e58ac0c7a18",
              "name": "\"READ Validation Lacks Length Limit\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"READ Validation Lacks Length Limit\" in ObjectScript refers to the situation where the `READ` command does not have a limit on the length of the input it can accept. This can lead to resource exhaustion or denial of service (DoS) attacks if an attacker supplies a very large input, especially in a network-exposed UI/API.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce limits and validation on the input after the `READ` command. This can be done by checking the length of the input and returning an error if it exceeds a certain limit. \n\nAdditionally, it is important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```objectscript\nread !, \"Lookup: \", lookup\nquit:(lookup = \"\") 0  // user entered nothing so return FALSE\nif $length(lookup) > 12 { // check if input length exceeds limit\n  write !, \"Error: Input too long\"\n  quit 0\n}\nif (lookup = \"?\") {\n  set type = \"help\", search = \"\"\n}\n// the RegEx accepts ###- or ###-###-#### only\nelseif $match(lookup, \"\\d{3}-(\\d{3}-\\d{4})?\") {\n  // ...\n}\n```\n\nIn this fix, the length of the input is checked after the `READ` command. If it exceeds 12 characters (the maximum length for the accepted formats), an error message is displayed and the function returns FALSE.\n\nRemember to enforce authorization using IRIS security (resources/roles) and/or application authentication. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript.\n\n## References\n\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/)\n- [Common Weakness Enumeration (CWE)](https://cwe.mitre.org/)\n- [InterSystems ObjectScript Documentation](https://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=GCOS_intro)\n- [InterSystems Security Administration Guide](https://docs.intersystems.com/latest/csp/docbook/Doc.View.cls?KEY=GSEC)"
              },
              "properties": {
                "cwe": [],
                "severity": "MEDIUM",
                "kind": "FAIL"
              }
            },
            {
              "id": "b7d2889e-cb47-33e2-86e2-13bf33b98386",
              "name": "\"Vulnerability of Unhandled Errors in Transaction Block without Rollback Mechanism\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability lies in the lack of error handling and rollback mechanism in the transaction block. In the provided ObjectScript code, the transaction starts with `tstart` and ends with `tcommit`. If any error occurs during the transaction, the code does not handle it and the transaction is not rolled back. This can lead to inconsistent data states and potential data loss.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to add error handling and a rollback mechanism in the transaction block. This can be achieved by using the `trollback` command in the catch block of a try-catch statement. This ensures that if any error occurs during the transaction, the changes made in the transaction are rolled back, maintaining the consistency of the data.\n\n## Source Code Fix Recommendation\n\n```objectscript\ntstart\ntry {\n  set ^PersonD(id) = answers  // store the answers\n\n  set $listbuild(name, phone, intdob) = answers\n  // split name into last and first for storage in index\n  set last = $piece(name, \",\", 1), first = $piece(name, \",\", 2)\n\n  /* the next three statements store data in subscripts.\n  because of the automatic sorting of subscripts,\n  this has the effect of building 3 indices: name, phone, and DOB */\n  set ^PersonI(\"Name\", last, first, id) = \"\"  // index last and first name\n  set ^PersonI(\"Phone\", phone) = id           // index the UNIQUE phone\n  set ^PersonI(\"DOB\", intdob, id) = \"\"        // index the internal DOB\n\n  /* these statements turn the id into a \"chunk #\" and a \"position #\"\n  and set a bit into the bitmap index */\n  set chunk = (id\\64000) + 1, position = (id#64000) + 1\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 1\n  tcommit\n} catch {\n  trollback\n  // handle the error, e.g., log it, notify the user, etc.\n}\n```\n\n## Library Dependencies\n\nThe provided code does not seem to have any external library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP Error Handling](https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html)\n- [CWE-391: Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This should be added/appended to the proposed source code fix recommendation."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-391",
                    "url": "https://cwe.mitre.org/data/definitions/391.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-391"
                ]
              }
            },
            {
              "id": "e4b58409-487c-3a5f-93f3-358dcf66133a",
              "name": "\"READ Validation Lacks Length Limit\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"READ Validation Lacks Length Limit\" in ObjectScript refers to the situation where the `READ` command does not have a limit on the length of the input it can accept. This can lead to resource exhaustion or denial of service (DoS) attacks if an attacker supplies a very large input, especially in a network-exposed UI/API.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce limits and validation on the input after the `READ` command. This can be done by checking the length of the input and returning an error if it exceeds a certain limit. \n\nAdditionally, it is important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```objectscript\nread !, \"Lookup: \", lookup\nquit:(lookup = \"\") 0  // user entered nothing so return FALSE\nif $length(lookup) > 12 { // check if input length exceeds limit\n  write !, \"Error: Input too long\"\n  quit 0\n}\nif (lookup = \"?\") {\n  set type = \"help\", search = \"\"\n}\n// the RegEx accepts ###- or ###-###-#### only\nelseif $match(lookup, \"\\d{3}-(\\d{3}-\\d{4})?\") {\n  // ...\n}\n```\n\nIn this fix, the length of the input is checked after the `READ` command. If it exceeds 12 characters (the maximum length for the accepted formats), an error message is displayed and the function returns FALSE.\n\nRemember to enforce authorization using IRIS security (resources/roles) and/or application authentication. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript.\n\n## References\n\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/)\n- [Common Weakness Enumeration (CWE)](https://cwe.mitre.org/)\n- [InterSystems ObjectScript Documentation](https://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=GCOS_intro)\n- [InterSystems Security Administration Guide](https://docs.intersystems.com/latest/csp/docbook/Doc.View.cls?KEY=GSEC)"
              },
              "properties": {
                "cwe": [],
                "severity": "MEDIUM",
                "kind": "FAIL"
              }
            },
            {
              "id": "72d80781-e079-3971-b3e2-6b71b145a3f1",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the deletion of a global node in the ObjectScript programming language without proper authorization verification and referential/index consistency maintenance. In the provided code snippet, `kill ^PersonD(id)`, a global node is being deleted without any checks for user authorization or referential integrity. This could potentially allow unauthorized users to delete data, leading to data loss or corruption.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before allowing a user to delete a global node. This can be achieved by using the `$SYSTEM.Security.Check()` method to verify if the user has the necessary privileges to perform the operation. Additionally, maintaining referential integrity is also important to prevent data corruption. This can be done by checking if the node to be deleted is not being referenced by any other nodes before proceeding with the deletion.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nset authorized = $SYSTEM.Security.Check(\"Delete PersonD\", \"%DB_USER\")\nif 'authorized {\n    write \"You do not have the necessary privileges to perform this operation.\"\n    quit\n}\n\nset refCheck = $data(^PersonD(id))\nif 'refCheck {\n    write \"The node you are trying to delete is being referenced by another node.\"\n    quit\n}\n\nkill ^PersonD(id)\n```\n\nIn this code, we first check if the user has the necessary privileges to delete a node from the `PersonD` global. If they do not, we output an error message and exit the operation. Next, we check if the node to be deleted is being referenced by any other nodes. If it is, we output an error message and exit the operation. Only if both checks pass do we proceed with the deletion of the node.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This should be supplemented by the source code fix recommendation.\n\n## References\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "80e5bcc0-bd1f-325f-881b-f661c4d44193",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability lies in the lack of authorization verification and referential/index consistency maintenance when deleting a global node in the ObjectScript programming language. In the provided code snippet, the `kill` command is used to delete a global node from the `^PersonI(\"Phone\", phone)` global array without any checks for user permissions or maintaining the consistency of the index.\n\nThis could potentially allow unauthorized users to delete data they shouldn't have access to, or cause inconsistencies in the index if the deleted node is still being referenced elsewhere in the application.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Implement authorization checks to ensure that the user has the necessary permissions to delete the global node. This can be done using the `$SYSTEM.Security.Check()` method in ObjectScript.\n\n2. Maintain referential/index consistency by ensuring that the deleted node is not being referenced elsewhere in the application. This can be done by implementing checks before the deletion operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nset resource = \"MyResource\"\nset permission = \"RW\"\nset result = $SYSTEM.Security.Check(resource, permission)\nif 'result {\n    write \"You do not have the necessary permissions to perform this operation.\",!\n    return 0\n}\nif $data(^PersonI(\"Phone\", phone)) {\n    kill ^PersonI(\"Phone\", phone)\n} else {\n    write \"The specified phone number does not exist in the index.\",!\n    return 0\n}\n```\n\nIn this code, we first check if the user has the necessary permissions to delete the global node. If they don't, we display an error message and exit the function. If they do, we then check if the node exists in the global array before deleting it. If it doesn't, we display an error message and exit the function.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This should be supplemented by the source code fix recommendation.\n\n## References\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "20132af7-7e3c-31be-bd4f-af6dee00c8e0",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability lies in the lack of authorization verification and referential/index consistency maintenance when deleting a global node in the ObjectScript programming language. The code `kill ^PersonI(\"Name\", last, first, id)` deletes a global node without checking if the user has the necessary permissions to perform this action. This could lead to unauthorized data manipulation or deletion. Additionally, the deletion of a global node could lead to inconsistencies in the database if there are references or indexes pointing to the deleted node.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement authorization checks before performing any sensitive operations such as deleting a global node. This can be done using the `$SYSTEM.Security.Check()` method in ObjectScript. Additionally, it is important to maintain referential and index consistency when deleting a global node. This can be achieved by updating or deleting any references or indexes pointing to the node before deleting it.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability:\n\n```objectscript\nset resource = \"%%resource.PersonI.Delete\"\nset permission = $SYSTEM.Security.Check(resource, \"\", 0)\nif 'permission {\n    write \"You do not have permission to delete this record.\",!\n    return 0\n}\n// Maintain referential/index consistency before deleting the node\n// ...\nkill ^PersonI(\"Name\", last, first, id)\n```\n\nThis code checks if the user has the necessary permissions to delete the record before performing the deletion. If the user does not have the necessary permissions, the code returns an error message and exits. Before deleting the node, the code also maintains referential and index consistency.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This should be supplemented by the source code fix recommendation.\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Top 10 - 2017: A5-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nAll links are valid and active for anonymous users."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "29ee34b7-ccf0-30dd-b66b-6f7bc6735d1b",
              "name": "\"Unprotected Transaction Block Vulnerability with Error Handling via Try/Catch and TROLLBACK\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the improper handling of transaction blocks in the ObjectScript programming language. The code snippet provided is an example of an unprotected transaction block, which means that it does not have proper error handling mechanisms in place. If an error occurs during the execution of the transaction block, the system will not be able to properly rollback the transaction, potentially leading to data inconsistency or corruption.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use the `try/catch` mechanism to handle any potential errors that may occur during the execution of the transaction block. This will allow the system to properly rollback the transaction in case of an error, ensuring data consistency and integrity.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\ntstart ()\ntry {\n  kill ^PersonD(id)\n  kill ^PersonI(\"Name\", last, first, id)\n  kill ^PersonI(\"Phone\", phone)\n  kill ^PersonI(\"DOB\", intdob, id)\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 0\n  tcommit\n} catch {\n  trollback\n  // Log the error for debugging purposes\n  write \"Error: \", $system.Status.GetErrorText($ZERROR),!\n}\n```\n\nIn this revised code, the transaction block is wrapped in a `try/catch` block. If an error occurs during the execution of the transaction, the `catch` block will be executed, rolling back the transaction and logging the error for debugging purposes.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP - Error Handling](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n- [CWE - Unprotected Transaction Block](https://cwe.mitre.org/data/definitions/668.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution for access control issues. This should be in addition to the proposed source code fix recommendation. In the source code fix recommendation, always use ObjectScript resource/privilege check via `$SYSTEM.Security.Check()` plus environment safeguards and real logging/auditing."
              },
              "properties": {
                "cwe": [],
                "severity": "MEDIUM",
                "kind": "FAIL"
              }
            },
            {
              "id": "1796d0d6-cb26-353c-bf29-b10f6a8320b8",
              "name": "\"Unprotected Transaction Block without Error Handling through TROLLBACK in Try/Catch\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the lack of error handling in transaction blocks in ObjectScript. In the provided code, a transaction is started with `tstart` and committed with `tcommit`, but there is no error handling mechanism in place. If an error occurs during the transaction, the code will not be able to handle it and the transaction will not be rolled back. This can lead to data inconsistency and potential data loss.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a `try/catch` block to handle any potential errors that may occur during the transaction. If an error is caught, the transaction should be rolled back using `trollback`. This will ensure that the database remains in a consistent state even if an error occurs.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```objectscript\ntstart\ntry {\n  set ^PersonD(id) = newanswers\n  if (newname '= currentname) {\n    // kill old name and add new name to index\n    kill ^PersonI(\"Name\", currentlast, currentfirst, id)\n    set ^PersonI(\"Name\", newlast, newfirst, id) = \"\"\n  }\n  if (newphone '= currentphone) {\n    // kill old phone and add new phone to index\n    kill ^PersonI(\"Phone\", currentphone)\n    set ^PersonI(\"Phone\", newphone) = id\n  }\n  if (newintdob '= currentintdob) {\n    // kill old dob and add new dob to index\n    kill ^PersonI(\"DOB\", currentintdob, id)\n    set ^PersonI(\"DOB\", newintdob, id) = \"\"\n  }\n  tcommit  // commit the transaction\n} catch {\n  trollback  // rollback the transaction in case of an error\n  // handle the error\n}\n```\n\nThis code will catch any errors that occur during the transaction and roll it back, preventing data inconsistency.\n\n## Library Dependencies\n\nThe provided code does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [CWE - Improper Control of a Resource Through its Lifetime](https://cwe.mitre.org/data/definitions/664.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This should be added/appended to the proposed source code fix recommendation."
              },
              "properties": {
                "cwe": [],
                "severity": "MEDIUM",
                "kind": "FAIL"
              }
            },
            {
              "id": "8ce05a7d-fb70-3819-9558-f376f862e78e",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the deletion of a global node in the ObjectScript programming language without proper authorization verification and referential/index consistency maintenance. This could potentially allow unauthorized users to delete data, leading to data loss and inconsistency.\n\nIn the provided code snippet, the `kill` command is used to delete a `PersonI` node from the global array. However, there is no check to verify if the user has the necessary permissions to perform this action.\n\n```objectscript\nkill ^PersonI(\"Name\", currentlast, currentfirst, id)\n```\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before performing any data modification operations. This can be achieved by using the `$SYSTEM.Security.Check()` method provided by InterSystems ObjectScript. This method checks if the current user has the necessary privileges to perform the action.\n\nAdditionally, it is important to maintain referential and index consistency when deleting nodes. This can be achieved by implementing checks to ensure that no other nodes are referencing the node to be deleted, and updating the indexes accordingly.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nset resource = \"PersonI\"\nset permission = \"W\"\n\nif '($SYSTEM.Security.Check(resource, permission)) {\n    write \"You do not have the necessary permissions to perform this action.\",!\n    return 0\n}\n\nif $data(^PersonI(\"Name\", currentlast, currentfirst, id)) {\n    kill ^PersonI(\"Name\", currentlast, currentfirst, id)\n} else {\n    write \"The specified node does not exist.\",!\n    return 0\n}\n```\n\nIn this fix, we first check if the user has the necessary permissions to delete a `PersonI` node. If they do not, we display an error message and exit the function. If they do, we then check if the node to be deleted exists. If it does, we delete it. If it does not, we display an error message and exit the function.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This source code fix is a secondary measure to ensure data integrity.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "5a8eaf42-0bfb-34db-9b94-e596fca1725d",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the lack of authorization verification and referential/index consistency maintenance when deleting a global node in the ObjectScript programming language. In the provided code snippet, the `kill` command is used to delete a node from the `^PersonI(\"Phone\", currentphone)` global without any checks for user permissions or referential integrity. This could potentially allow unauthorized users to delete data, leading to data loss or corruption.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before performing any data modification operations. This can be achieved by using the `$SYSTEM.Security.Check()` method to verify if the current user has the necessary permissions to perform the operation. \n\nAdditionally, maintaining referential integrity is also important when deleting data. Before deleting a node, checks should be made to ensure that no other data depends on it. If other data does depend on it, appropriate actions should be taken to handle this, such as updating the dependent data or preventing the deletion.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nset resource = \"MyResource\"\nset permission = \"RW\"\nset result = $SYSTEM.Security.Check(resource, permission)\nif 'result {\n    write \"You do not have the necessary permissions to perform this operation.\",!\n    return 0\n}\n\nset refCheck = $data(^PersonI(\"Phone\", currentphone))\nif 'refCheck {\n    write \"Cannot delete. Data is referenced elsewhere.\",!\n    return 0\n}\n\nkill ^PersonI(\"Phone\", currentphone)\n```\n\nIn this code, `$SYSTEM.Security.Check()` is used to check if the current user has read-write (`RW`) permissions for the `MyResource` resource. If the user does not have the necessary permissions, a message is displayed and the operation is aborted. \n\nNext, `$data()` is used to check if the node to be deleted is referenced elsewhere. If it is, a message is displayed and the operation is aborted. \n\nOnly if the user has the necessary permissions and the node is not referenced elsewhere is the `kill` command executed.\n\nNote: This code fix is a part of the solution. Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution.\n\n## References\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "1c63cc4b-0cc5-3298-8eb0-523a47135950",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the deletion of a global node in the ObjectScript programming language without proper authorization verification and referential/index consistency maintenance. In the provided code snippet, the `kill` command is used to delete a node from the `^PersonI(\"DOB\", intdob, id)` global array. If an attacker gains access to this functionality, they could potentially delete data without authorization, leading to data loss and inconsistency.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before allowing the deletion of any data. This can be achieved by using the `$SYSTEM.Security.Check()` method provided by InterSystems ObjectScript. This method checks if the current user has the necessary privileges to perform the action.\n\nAdditionally, it is important to maintain referential and index consistency when deleting data. This can be achieved by implementing checks to ensure that no other data is referencing the data to be deleted, and updating any indexes as necessary.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nset resource = \"MyResource\"\nset permission = \"RW\"\nset result = $SYSTEM.Security.Check(resource, permission)\nif 'result {\n    write \"You do not have the necessary permissions to perform this action.\",!\n    return 0\n}\n\n// Check for referential integrity before deletion\nif $data(^PersonI(\"DOB\", intdob, id)) {\n    // Perform deletion\n    kill ^PersonI(\"DOB\", intdob, id)\n} else {\n    write \"The data you are trying to delete does not exist.\",!\n    return 0\n}\n```\n\nIn this code, we first check if the current user has the necessary permissions to perform the action. If they do not, we display an error message and exit the function. If they do, we then check if the data to be deleted exists. If it does, we delete it. If it does not, we display an error message and exit the function.\n\nNote: This code fix is a secondary measure. The primary solution should be enforcing authorization using IRIS security (resources/roles) and/or application authentication.\n\n## References\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "33f20dda-eb54-3410-96f5-2d82070864bf",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability lies in the lack of authorization verification before deleting a global node in the ObjectScript programming language. The code `kill ^PersonI(\"DOB\", currentintdob, id)` deletes a global node without checking if the user has the necessary permissions to perform this action. This could potentially allow unauthorized users to delete important data.\n\nMoreover, the code does not maintain referential/index consistency. Deleting a global node without ensuring that all references to it are also deleted can lead to inconsistencies in the data and may cause errors in the future.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement authorization checks before performing any action that modifies data. This can be done using the `$SYSTEM.Security.Check()` method provided by InterSystems ObjectScript. \n\nIn addition, it is important to maintain referential/index consistency when deleting global nodes. This can be achieved by ensuring that all references to a node are also deleted when the node itself is deleted.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```objectscript\nset resource = \"%%resource\"\nset permission = \"W\"\nset access = $SYSTEM.Security.Check(resource, permission)\nif 'access {\n    write \"You do not have permission to delete this node.\",!\n    return 0\n}\nkill ^PersonI(\"DOB\", currentintdob, id)\n```\n\nIn this code, we first define the resource and permission required to delete a node. We then use the `$SYSTEM.Security.Check()` method to check if the user has the necessary permissions. If the user does not have the necessary permissions, we display an error message and exit the function.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This source code fix is a secondary measure to ensure that only authorized users can delete nodes.\n\n## Library Dependencies\n\nThe code does not require any library dependencies to execute properly.\n\n## OWASP and CWE Resources\n\n- [OWASP Authorization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "dde36b30-4084-3114-9c88-74272d0a459d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry1.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 1,
                  "endLine": 10,
                  "endColumn": 1,
                  "snippet": {
                    "text": "  read !, \"DOB: \", dob"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "a16517c0f7a1862ad00bed6bab01410c3c653d18c2f71619a8ffc6c248854784",
            "glog-pfp-ruleFileCode/v1": "f18002dcec8b804fc4aff86ddc75b0318e4aa913b880f394fc091504f48d1af0"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f18002dcec8b804fc4aff86ddc75b0318e4aa913b880f394fc091504f48d1af0"
          },
          "properties": {}
        },
        {
          "ruleId": "435010c9-558e-3363-b9d6-0240e98604bb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unlimited Length and Lack of Validation in READ Function Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 1,
                  "endLine": 15,
                  "endColumn": 25,
                  "snippet": {
                    "text": "  read !, \"Name: \", name"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1588fd68e296aefb65029f3ddd8a6aa0477c00f7d05c9f86e8e3ac695b8f4a04",
            "glog-pfp-ruleFileCode/v1": "c106970a3015e1768d0c46da207f0b746f250550d6e18743983cea2298ec866b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c106970a3015e1768d0c46da207f0b746f250550d6e18743983cea2298ec866b"
          },
          "properties": {}
        },
        {
          "ruleId": "4e6b4276-0f0e-32cd-8208-0994f0e7ce53",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted READ Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 1,
                  "endLine": 18,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  read !, \"DOB: \", dob"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5751a49c2db36846c77ea9f6320c4c2775bf22601f0d6786d67653555592de83",
            "glog-pfp-ruleFileCode/v1": "f68b5162038558ce480a5a02eef7addf417debda8710a3a71119858aab2e0b0c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f68b5162038558ce480a5a02eef7addf417debda8710a3a71119858aab2e0b0c"
          },
          "properties": {}
        },
        {
          "ruleId": "cafcafb1-54e4-3005-a9fe-3fd052454113",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry1.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 1,
                  "endLine": 8,
                  "endColumn": 27,
                  "snippet": {
                    "text": "  read !, \"Phone: \", phone"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e826f109c4b45f10eee9761c945719176bc6b4aa43aa8b528eecb0f23972e1e9",
            "glog-pfp-ruleFileCode/v1": "4d988c25ff43dbdbaf7a05cd1696f869fd7cba05aa4552c4982d3b4e94de80dd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "4d988c25ff43dbdbaf7a05cd1696f869fd7cba05aa4552c4982d3b4e94de80dd"
          },
          "properties": {}
        },
        {
          "ruleId": "6c9216c5-1199-3e3d-be32-76444508b497",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 1,
                  "endLine": 17,
                  "endColumn": 27,
                  "snippet": {
                    "text": "  read !, \"Phone: \", phone"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f88fed0aa0791482ac2ccafcd80ab66c6fd9df6132b217e52ac397e114e40ec3",
            "glog-pfp-ruleFileCode/v1": "bdb55c573e4c113c915bdee6240a0a5f7481ccdaf9736a6b7f6b9901f2e6ef18"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "bdb55c573e4c113c915bdee6240a0a5f7481ccdaf9736a6b7f6b9901f2e6ef18"
          },
          "properties": {}
        },
        {
          "ruleId": "cd5c0c9e-441e-3ab5-ae94-990b4540352a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Vulnerability: No Length Limit and Lacks Downstream Validation - Suggest Adding #maxlen for Enhanced Security\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 3,
                  "endLine": 18,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"Name: \", name\n    return:(name = \"\") 0  // user entered nothing so return FALSE, exit loop AND method\n  } while '..ValidName(name)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "88330178e5906f5a327710de523a76fc6012996262e842edc3d3ef9e40b52042",
            "glog-pfp-ruleFileCode/v1": "72f9cb269d60974d2dec07781c8313d932a75856831e71295bf90cefa4d10a8a"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "72f9cb269d60974d2dec07781c8313d932a75856831e71295bf90cefa4d10a8a"
          },
          "properties": {}
        },
        {
          "ruleId": "3ed646f7-709c-3f10-a7ac-befa9871452f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ lacks length limit and downstream validation, consider implementing #maxlen for enhanced security.\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 3,
                  "endLine": 26,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"DOB: \", dob\n  } while '..ValidDOB(dob, .intdob)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e6d0ee4d2d6533856c3de647e91454b57aa63cb689353fc9e354fd62284dafac",
            "glog-pfp-ruleFileCode/v1": "94dc920180ff2b72d37f7c85a52814c9cf11f1d1042a584c14a23c0cc8b7f587"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "94dc920180ff2b72d37f7c85a52814c9cf11f1d1042a584c14a23c0cc8b7f587"
          },
          "properties": {}
        },
        {
          "ruleId": "29b13a5d-59a3-3bdc-bf3b-705753a4df6b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry1.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 1,
                  "endLine": 6,
                  "endColumn": 26,
                  "snippet": {
                    "text": "  read !, \"Name: \" , name"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1eb0a19967bdf3a84b461d73a43ca1d67a24b112574176098cd2c9bc56d8ec1f",
            "glog-pfp-ruleFileCode/v1": "9a56055f23c0da538635528a49f93c4c2289ddec20bf6ba59bf5a8760bbe5f4e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9a56055f23c0da538635528a49f93c4c2289ddec20bf6ba59bf5a8760bbe5f4e"
          },
          "properties": {}
        },
        {
          "ruleId": "42493282-59f2-325f-a414-89b76af33cf1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 3,
                  "endLine": 19,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"Name: \", name\n    return:(name = \"\") 0  // user entered nothing so return FALSE, exit loop AND method\n  } While '..ValidName(name)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "a26a27f1f7759a90be695423e71456f39c405514740fb649ed46101e1f4cce8a",
            "glog-pfp-ruleFileCode/v1": "b7eef19b46d93b7571a649686a9292b219f18d52d1f86e4406b849c6e49c91f1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "b7eef19b46d93b7571a649686a9292b219f18d52d1f86e4406b849c6e49c91f1"
          },
          "properties": {}
        },
        {
          "ruleId": "54211a2f-95e9-3e07-897e-253a1bd9dc64",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 3,
                  "endLine": 23,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"Phone (617): \", phone\n  } While '..ValidPhone(.phone)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2224ea682cca3496a5065321a9b213e3b1c825283f2c495757f70f950307605b",
            "glog-pfp-ruleFileCode/v1": "0526502925ea06aca6d1dfb2d861bdb9d35e6a60becfaf6287af14ebcb3c3c6e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0526502925ea06aca6d1dfb2d861bdb9d35e6a60becfaf6287af14ebcb3c3c6e"
          },
          "properties": {}
        },
        {
          "ruleId": "a812b057-eba4-3975-85d0-6cb81435013b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Vulnerability: No Length Limit and Lacks Downstream Validation, Suggests Adding #maxlen for Enhanced Security\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 3,
                  "endLine": 22,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"Phone (617): \", phone\n  } while '..ValidPhone(.phone)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "aa241c83c46100896efcf086be922b16a9d5bbf34ebe222e5e7231ccd43bcf56",
            "glog-pfp-ruleFileCode/v1": "17f42aea76a5e604c169425e393560120a0b62ef05cdf5447627310284e761c3"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "17f42aea76a5e604c169425e393560120a0b62ef05cdf5447627310284e761c3"
          },
          "properties": {}
        },
        {
          "ruleId": "499a80f3-9d51-308a-a8b7-d54e1e77d26a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Vulnerability: No Length Limit and Lacks Downstream Validation - Suggest Adding #maxlen for Enhanced Security\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 3,
                  "endLine": 27,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"DOB: \", dob\n  } While '..ValidDOB(dob, .intdob)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "12d7de5090d32ba81c31cd35728ebdb7f7dae490f24ead4f33f52990efc9ff5f",
            "glog-pfp-ruleFileCode/v1": "eace1c7a8f7c366eb78748ab636f9891fd378660c60dd6167f5e8b1c77ed71cd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "eace1c7a8f7c366eb78748ab636f9891fd378660c60dd6167f5e8b1c77ed71cd"
          },
          "properties": {}
        },
        {
          "ruleId": "5ec0f754-a889-33c5-965e-aa50f1b6348e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential race condition in uniqueness check with separate SET method: consider using LOCK for validate-store operation."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 5,
                  "endLine": 56,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    if $data(^PersonI(\"Phone\", phone)) {\n      write !, \"Phone number already in use\"\n      return 0"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "d9ffcb402aaefee9aafdeb7fbd1e0302b89f01ce1dc7e0ae4d276782c216d4ae",
            "glog-pfp-ruleFileCode/v1": "3380a87a09c4db7b2f36452d037308798a281171de8ab560de6475418f15d5dd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3380a87a09c4db7b2f36452d037308798a281171de8ab560de6475418f15d5dd"
          },
          "properties": {}
        },
        {
          "ruleId": "01879d89-0731-3f2d-8f28-222b8397169c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Global Root Deletion: Admin-Only Access, Not for Production Use\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 137,
                  "startColumn": 1,
                  "endLine": 137,
                  "endColumn": 26,
                  "snippet": {
                    "text": "  kill ^PersonD, ^PersonI"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f7acc2d8fb698b79dbe5f1419cfb25ea127a904bf8965d4259905f2cd4f7f53e",
            "glog-pfp-ruleFileCode/v1": "71bf54ba2a9144e1b91e28200b017cdf95ff6c26b1370006bc6cd7ee99d51ff9"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "71bf54ba2a9144e1b91e28200b017cdf95ff6c26b1370006bc6cd7ee99d51ff9"
          },
          "properties": {}
        },
        {
          "ruleId": "472c15e6-ffcc-3a94-8295-65e61fb52e2d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Data Reset Pattern Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 1,
                  "endLine": 137,
                  "endColumn": 9,
                  "snippet": {
                    "text": "ClassMethod Load()\n{\n  kill ^PersonD, ^PersonI"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e46d2a30aa0d31f66fc3c4492caeab96a9e23b5f5e3d2441fd797183e8a8944b",
            "glog-pfp-ruleFileCode/v1": "2c9e244929f3b8095ba97e90535f6a3b94412ed8b8caf76810149bf00d84ef9f"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2c9e244929f3b8095ba97e90535f6a3b94412ed8b8caf76810149bf00d84ef9f"
          },
          "properties": {}
        },
        {
          "ruleId": "bf4b8989-114a-35f2-b7a6-e46ab8b15089",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Consider using TSTART/TCOMMIT for consistency when multiple related SETs follow $INCREMENT outside transaction."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 1,
                  "endLine": 110,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n  set id = $increment(^PersonD)  // use $increment to generate a new ID"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "8b24776f23797e5a44e106662418a1549d9214b4c7ac7baeb8a2c6f3ab9e3afd",
            "glog-pfp-ruleFileCode/v1": "135fdad62d87be0a6f530642f119c099171187f5db1c23973e0728a2ad18667c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "135fdad62d87be0a6f530642f119c099171187f5db1c23973e0728a2ad18667c"
          },
          "properties": {}
        },
        {
          "ruleId": "4d0c456f-a42e-311e-b69e-14311e702bb7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Admin-Only Restriction Required for Detected Extent Deletion Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 35,
                  "endLine": 138,
                  "endColumn": 47,
                  "snippet": {
                    "text": "  do ##class(ObjectScript.Person).%KillExtent()"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "85887d486731a3fbc39cb1daf9906e7d01cc348c959a812be3eef71a9837b677",
            "glog-pfp-ruleFileCode/v1": "4490d8d8e00d0a76642c1ef08ef845f36dc24664bbc7b8c452933a22ce1968a3"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "4490d8d8e00d0a76642c1ef08ef845f36dc24664bbc7b8c452933a22ce1968a3"
          },
          "properties": {}
        },
        {
          "ruleId": "1f4724ef-1c72-3b83-aac4-2e58ac0c7a18",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Validation Lacks Length Limit\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 1,
                  "endLine": 26,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  read !, \"Lookup: \", lookup\n  return:(lookup = \"\") 0  // user entered nothing so return FALSE\n  if (lookup = \"?\") {\n    set type = \"help\", search = \"\"\n  }\n  // the RegEx accepts ###- or ###-###-#### only\n  elseif $match(lookup, \"\\d{3}-(\\d{3}-\\d{4})?\") {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c369cf38a9c01c51c8e1910e8f167d7748ea16733959a50b230ad1163fe5857e",
            "glog-pfp-ruleFileCode/v1": "50697fdb20a31b2a0f51c7ac791d19a58529da92d4791f879ba2e621eaf0936d"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "50697fdb20a31b2a0f51c7ac791d19a58529da92d4791f879ba2e621eaf0936d"
          },
          "properties": {}
        },
        {
          "ruleId": "b7d2889e-cb47-33e2-86e2-13bf33b98386",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Vulnerability of Unhandled Errors in Transaction Block without Rollback Mechanism\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 3,
                  "endLine": 130,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  tstart\n  set ^PersonD(id) = answers  // store the answers\n\n  set $listbuild(name, phone, intdob) = answers\n  // split name into last and first for storage in index\n  set last = $piece(name, \",\", 1), first = $piece(name, \",\", 2)\n\n\t/* the next three statements store data in subscripts.\n  because of the automatic sorting of subscripts,\n  this has the effect of building 3 indices: name, phone, and DOB */\n  set ^PersonI(\"Name\", last, first, id) = \"\"  // index last and first name\n  set ^PersonI(\"Phone\", phone) = id           // index the UNIQUE phone\n  set ^PersonI(\"DOB\", intdob, id) = \"\"        // index the internal DOB\n\n\t/* these statements turn the id into a \"chunk #\" and a \"position #\"\n  and set a bit into the bitmap index */\n  set chunk = (id\\64000) + 1, position = (id#64000) + 1\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 1\n  tcommit"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5b7be2c20a33b3d2a258344cb731f430ec11b3ddbc054b69dab7828a318fe75c",
            "glog-pfp-ruleFileCode/v1": "8205c180161f40bf01a292183503ab96dd94245da5f906dd4b394539173317d8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8205c180161f40bf01a292183503ab96dd94245da5f906dd4b394539173317d8"
          },
          "properties": {}
        },
        {
          "ruleId": "e4b58409-487c-3a5f-93f3-358dcf66133a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Validation Lacks Length Limit\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 1,
                  "endLine": 26,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  read !, \"Lookup: \", lookup\n  return:(lookup = \"\") 0  // user entered nothing so return FALSE\n  if (lookup = \"?\") {\n    set type = \"help\", search = \"\"\n  }\n  // the RegEx accepts ###- or ###-###-#### only\n  elseif $match(lookup, \"\\d{3}-(\\d{3}-\\d{4})?\") {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7ebb7b591794a34ddfcee13e44218813c1fd694d9c58578fbf241320436c6e0c",
            "glog-pfp-ruleFileCode/v1": "d42ee2aee074bd9274ccd3d08e7d620fa345b7c23d07ebfc5c7418898b1b7613"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "d42ee2aee074bd9274ccd3d08e7d620fa345b7c23d07ebfc5c7418898b1b7613"
          },
          "properties": {}
        },
        {
          "ruleId": "72d80781-e079-3971-b3e2-6b71b145a3f1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 227,
                  "startColumn": 1,
                  "endLine": 227,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonD(id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ba0fc87304c8cfdd7a5ae46bbd6732cb705590a374a0af6c559ee98fd900fc06",
            "glog-pfp-ruleFileCode/v1": "fbfa074c25598a93d276a65d1cd8f7625c3162ef0859e7ae8e56ed97364861dd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "fbfa074c25598a93d276a65d1cd8f7625c3162ef0859e7ae8e56ed97364861dd"
          },
          "properties": {}
        },
        {
          "ruleId": "80e5bcc0-bd1f-325f-881b-f661c4d44193",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 229,
                  "startColumn": 1,
                  "endLine": 229,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonI(\"Phone\", phone)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f6bce1cae137605db71abc33ba5171de8773f03c266f9ae5b8b2571cc8f993c6",
            "glog-pfp-ruleFileCode/v1": "8c64b374d9bba1d82fb6a3e95720ba33c7ba16252397344301bf24bc84a6d6e1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8c64b374d9bba1d82fb6a3e95720ba33c7ba16252397344301bf24bc84a6d6e1"
          },
          "properties": {}
        },
        {
          "ruleId": "20132af7-7e3c-31be-bd4f-af6dee00c8e0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 228,
                  "startColumn": 1,
                  "endLine": 228,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonI(\"Name\", last, first, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "39ccfa5bfee025a32458dd23f11fa0fbde5a5e84975962b13a6dc5c3c7935ff7",
            "glog-pfp-ruleFileCode/v1": "9cc9bcc620932ba42597e1a6210b9aa47ad40853372fda4cf8a57843ca87c6d3"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9cc9bcc620932ba42597e1a6210b9aa47ad40853372fda4cf8a57843ca87c6d3"
          },
          "properties": {}
        },
        {
          "ruleId": "29ee34b7-ccf0-30dd-b66b-6f7bc6735d1b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Unprotected Transaction Block Vulnerability with Error Handling via Try/Catch and TROLLBACK\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 226,
                  "startColumn": 3,
                  "endLine": 232,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  tstart\n  kill ^PersonD(id)\n  kill ^PersonI(\"Name\", last, first, id)\n  kill ^PersonI(\"Phone\", phone)\n  kill ^PersonI(\"DOB\", intdob, id)\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 0\n  tcommit"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "524a8872c2c71713c7d233796ce2436aa88e403eae222244eba769be399d226c",
            "glog-pfp-ruleFileCode/v1": "6d4ad56227d20f25898055bfda0ca64e27ba177955c1efc72131748ef0ad1950"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "6d4ad56227d20f25898055bfda0ca64e27ba177955c1efc72131748ef0ad1950"
          },
          "properties": {}
        },
        {
          "ruleId": "1796d0d6-cb26-353c-bf29-b10f6a8320b8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Unprotected Transaction Block without Error Handling through TROLLBACK in Try/Catch\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 310,
                  "startColumn": 3,
                  "endLine": 327,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  tstart\n  set ^PersonD(id) = newanswers\n  if (newname '= currentname) {\n    // kill old name and add new name to index\n    kill ^PersonI(\"Name\", currentlast, currentfirst, id)\n    set ^PersonI(\"Name\", newlast, newfirst, id) = \"\"\n  }\n  if (newphone '= currentphone) {\n    // kill old phone and add new phone to index\n    kill ^PersonI(\"Phone\", currentphone)\n    set ^PersonI(\"Phone\", newphone) = id\n  }\n  if (newintdob '= currentintdob) {\n    // kill old dob and add new dob to index\n    kill ^PersonI(\"DOB\", currentintdob, id)\n    set ^PersonI(\"DOB\", newintdob, id) = \"\"\n  }\n  tcommit  // commit the transaction"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "eea00ea157f2529b3bbabc4f5e20dc33d25f70cf3ead49ab062e1d7158728039",
            "glog-pfp-ruleFileCode/v1": "7d97a0da241969d8b6bc1b8ef7d29dc93357400c5eebe15494f8c5338fd2ade8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7d97a0da241969d8b6bc1b8ef7d29dc93357400c5eebe15494f8c5338fd2ade8"
          },
          "properties": {}
        },
        {
          "ruleId": "8ce05a7d-fb70-3819-9558-f376f862e78e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 314,
                  "startColumn": 1,
                  "endLine": 314,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    kill ^PersonI(\"Name\", currentlast, currentfirst, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "549252a2a90c1958ff803d2a3c54e0e499f769457676cd390c226e4576cd765e",
            "glog-pfp-ruleFileCode/v1": "c2e3657171377b6ae29f818e99747196ae676817b036847bda59fb29f8bc456b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c2e3657171377b6ae29f818e99747196ae676817b036847bda59fb29f8bc456b"
          },
          "properties": {}
        },
        {
          "ruleId": "5a8eaf42-0bfb-34db-9b94-e596fca1725d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 319,
                  "startColumn": 1,
                  "endLine": 319,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    kill ^PersonI(\"Phone\", currentphone)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "811ecacde85f4a18d3a70ef32bdb6c98ef22c90eafe44b1a2361d821cbcfed55",
            "glog-pfp-ruleFileCode/v1": "08d790c5f05b94539a31cab33d359f9a0a2e5984fb4fc75e29a9a8a43d1419eb"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "08d790c5f05b94539a31cab33d359f9a0a2e5984fb4fc75e29a9a8a43d1419eb"
          },
          "properties": {}
        },
        {
          "ruleId": "1c63cc4b-0cc5-3298-8eb0-523a47135950",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 230,
                  "startColumn": 1,
                  "endLine": 230,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonI(\"DOB\", intdob, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ae317b0b2529d136a98727ca20c860a5f69130866ce7764ab51296235befc3f1",
            "glog-pfp-ruleFileCode/v1": "72280b74bd40d6c1b6730110938a1ed6931199110b9f9e2b968194cfea2c44ce"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "72280b74bd40d6c1b6730110938a1ed6931199110b9f9e2b968194cfea2c44ce"
          },
          "properties": {}
        },
        {
          "ruleId": "33f20dda-eb54-3410-96f5-2d82070864bf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 1,
                  "endLine": 324,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    kill ^PersonI(\"DOB\", currentintdob, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "080f2e69363b80969258314e19cf7dcee5d1c69c12150f348c143c8f7601d902",
            "glog-pfp-ruleFileCode/v1": "0418632810a07515c059cac234c6be7ec2cb747aae142d87bf017991cf6a047f"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0418632810a07515c059cac234c6be7ec2cb747aae142d87bf017991cf6a047f"
          },
          "properties": {}
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}