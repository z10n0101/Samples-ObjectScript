{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "cafcafb1-54e4-3005-a9fe-3fd052454113",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn the ObjectScript programming language, the `read` command is used to get input from the user. If the `read` command is used without any restrictions on the length of the input, it can lead to a vulnerability known as Unrestricted Read Length or Lack of Input Validation Vulnerability. This vulnerability can be exploited by an attacker to cause a Denial of Service (DoS) attack by providing a very large input, which can lead to resource exhaustion.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the length of the input that can be read. This can be done by reading the input into a variable and then checking the length of the variable. If the length of the variable exceeds the maximum allowed length, the program should discard the input and ask the user to enter the input again.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability in the provided code:\n\n```objectscript\nread !, \"Phone: \", phone\nif $LENGTH(phone) > 15 {\n    write \"Phone number is too long. Please enter a valid phone number.\"\n} else {\n    // Continue with the rest of the code\n}\n```\n\nIn this fix, the `read` command is used to get the phone number from the user. The length of the phone number is then checked using the `$LENGTH` function. If the length of the phone number is greater than 15, the program writes an error message and asks the user to enter a valid phone number.\n\n## Library Dependencies\n\nThe provided code does not require any library dependencies to execute properly.\n\n## OWASP Resources\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "dde36b30-4084-3114-9c88-74272d0a459d",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn the InterSystems ObjectScript programming language, the `read` command is used to get input from the user. If the `read` command is used without any restrictions on the length of the input, it can lead to a vulnerability known as Unrestricted Read Length or Lack of Input Validation Vulnerability. This vulnerability can be exploited by an attacker to cause a Denial of Service (DoS) attack by providing a very large input, which can lead to resource exhaustion.\n\n## Mitigation\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the length of the input that can be read. This can be done by reading the input into a variable and then checking the length of the variable. If the length of the variable exceeds the maximum allowed length, the program should discard the input and ask the user to enter the input again.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability in the provided code:\n\n```objectscript\nread !, \"DOB: \", dob\nif $LENGTH(dob) > MAX_LENGTH {\n    write \"Input is too long. Please enter a DOB of length less than \", MAX_LENGTH, \".\"\n    // Ask the user to enter the input again\n    read !, \"DOB: \", dob\n}\n```\n\nIn the above code, `MAX_LENGTH` is a constant that defines the maximum allowed length of the input. The `if` statement checks if the length of the input exceeds `MAX_LENGTH`. If it does, the program discards the input and asks the user to enter the input again.\n\nNote: This code fix does not require any additional library dependencies.\n\n## OWASP Resources\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP Unrestricted File Upload](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  },
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400",
                  "CWE-20"
                ]
              }
            },
            {
              "id": "29b13a5d-59a3-3bdc-bf3b-705753a4df6b",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is an unrestricted read length or lack of input validation vulnerability in the ObjectScript programming language. This vulnerability occurs when the program does not validate or incorrectly validates input. This can lead to various types of attacks, such as buffer overflow, denial of service, or other unexpected behavior.\n\nIn the provided code snippet, the `read` command is used without any restrictions on the length of the input, which can lead to resource exhaustion or denial of service if an attacker provides a very large input.\n\n```objectscript\nread !, \"Name: \" , name\n```\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the length of the input. This can be done by reading the input into a temporary variable, checking its length, and then assigning it to the `name` variable if it meets the criteria.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nread !, \"Name: \", temp\nif $length(temp) > 100 {\n    write \"Input is too long. Please enter a name up to 100 characters.\"\n} else {\n    set name = temp\n}\n```\n\nIn this fix, the input is first read into a temporary variable `temp`. Then, the length of `temp` is checked. If it is more than 100 characters, an error message is displayed. Otherwise, `temp` is assigned to `name`.\n\n## Library Dependencies\n\nThe provided code snippet does not require any library dependencies to execute properly.\n\n## OWASP Resources and CWE\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This should be in addition to the proposed source code fix recommendation."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-20"
                ]
              }
            },
            {
              "id": "435010c9-558e-3363-b9d6-0240e98604bb",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Unrestricted Read Length or Lack of Input Validation Vulnerability\" in ObjectScript programming language is a security flaw that allows an attacker to cause a denial of service (DoS) attack by providing an excessively large input. This vulnerability occurs when the program does not validate or improperly validates the length of the input before reading it. This can lead to resource exhaustion as the system tries to process the large input, causing the application to slow down or crash, resulting in a DoS condition.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the size of the input that can be processed by the application. This can be achieved by checking the length of the input and rejecting it if it exceeds a certain limit. Additionally, it is also important to handle exceptions that may occur when the input is too large to prevent the application from crashing.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability in the provided code:\n\n```objectscript\nread !, \"Name: \", name\nif $LENGTH(name)>100 {\n    write \"Input is too long. Please enter a name that is 100 characters or less.\"\n} else {\n    // Process the input\n}\n```\n\nIn this fix, the length of the input is checked before it is processed. If the input is longer than 100 characters, an error message is displayed and the input is not processed.\n\n## Library Dependencies\n\nThe provided code does not require any library dependencies to execute properly.\n\n## OWASP Resources\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP Unrestricted File Upload](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)\n\nNote: Always ensure to enforce authorization using IRIS security (resources/roles) and/or application authentication as a primary solution. This should be in addition to the proposed solution in the source code."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  },
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400",
                  "CWE-20"
                ]
              }
            },
            {
              "id": "4e6b4276-0f0e-32cd-8208-0994f0e7ce53",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn the InterSystems ObjectScript programming language, the `read` command is used to get input from the user. If the `read` command is used without any restrictions on the length of the input, it can lead to a vulnerability known as Unrestricted Read Length or Lack of Input Validation Vulnerability. This vulnerability can be exploited by an attacker to cause a Denial of Service (DoS) attack by providing a very large input, which can lead to resource exhaustion.\n\n## Mitigation\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the length of the input that can be read. This can be done by reading the input into a variable and then checking the length of the variable. If the length of the variable exceeds the maximum allowed length, the program should discard the input and ask the user to enter the input again.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability in the provided code:\n\n```objectscript\nread !, \"DOB: \", dob\nif $LENGTH(dob) > MAX_LENGTH {\n    write \"Input is too long. Please enter a DOB of length less than \", MAX_LENGTH, \".\"\n    // Ask the user to enter the input again\n    read !, \"DOB: \", dob\n}\n```\n\nIn the above code, `MAX_LENGTH` is a constant that defines the maximum allowed length of the input. The `if` statement checks if the length of the input exceeds `MAX_LENGTH`. If it does, the program discards the input and asks the user to enter the input again.\n\nNote: This code fix does not require any additional library dependencies.\n\n## OWASP Resources\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP Unrestricted File Upload](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  },
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400",
                  "CWE-20"
                ]
              }
            },
            {
              "id": "6c9216c5-1199-3e3d-be32-76444508b497",
              "name": "Unrestricted Read Length or Lack of Input Validation Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn the ObjectScript programming language, the `read` command is used to get input from the user. If the `read` command is used without any restrictions on the length of the input, it can lead to a vulnerability known as Unrestricted Read Length or Lack of Input Validation Vulnerability. This vulnerability can be exploited by an attacker to cause a Denial of Service (DoS) attack by providing a very large input, which can lead to resource exhaustion.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce input validation and limit the length of the input that can be read. This can be done by reading the input into a variable and then checking the length of the variable. If the length of the variable exceeds the maximum allowed length, the program should discard the input and ask the user to enter the input again.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability in the provided code:\n\n```objectscript\nread !, \"Phone: \", phone\nif $LENGTH(phone) > 15 {\n    write \"Phone number is too long. Please enter a valid phone number.\"\n} else {\n    // Continue with the rest of the code\n}\n```\n\nIn this fix, the `read` command is used to get the phone number from the user. The length of the phone number is then checked using the `$LENGTH` function. If the length of the phone number is greater than 15, the program writes an error message and asks the user to enter a valid phone number.\n\n## Library Dependencies\n\nThe provided code does not require any library dependencies to execute properly.\n\n## OWASP Resources\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "cd5c0c9e-441e-3ab5-ae94-990b4540352a",
              "name": "\"READ Vulnerability: No Length Limit and Lacks Downstream Validation - Suggest Adding #maxlen for Enhanced Security\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability is related to the `READ` command in ObjectScript, which is used to get user input. In the provided code snippet, there is no limit on the length of the input that can be provided by the user. This can lead to resource exhaustion or denial of service (DoS) attacks if an attacker provides a very large input. Additionally, the input is not validated downstream, which can lead to further security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the user input and to validate the input downstream. This can be done by checking the length of the input string after it is read and before it is used in the rest of the program. If the length of the input exceeds the limit, the program should reject the input and ask the user to enter it again. Additionally, the input should be validated to ensure it meets the required format and does not contain any malicious data.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\ndo {\n    read !, \"Name: \", name\n    if $LENGTH(name) > 100 { // limit the length of the input to 100 characters\n        write !, \"Input is too long. Please enter a name with 100 characters or less.\"\n    } else {\n        return:(name = \"\") 0  // user entered nothing so return FALSE, exit loop AND method\n    }\n} while '..ValidName(name)\n```\n\nIn this fix, the length of the input is checked after it is read. If the length exceeds 100 characters, an error message is displayed and the user is asked to enter the input again. The `ValidName` method should also be updated to validate the format of the input.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## OWASP Resources and CWE\n\n- [OWASP Top 10 - A1 Injection](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)\n\n## Note\n\nIn addition to the source code fix, it is recommended to enforce authorization using IRIS security (resources/roles) and/or application authentication. This can be done using the `$SYSTEM.Security.Check()` method in ObjectScript. This should be combined with environment safeguards and real logging/auditing to ensure the security of the application."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-20"
                ]
              }
            },
            {
              "id": "42493282-59f2-325f-a414-89b76af33cf1",
              "name": "\"READ lacks length limit and downstream validation, consider implementing #maxlen for enhanced security.\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the lack of a length limit and downstream validation when reading user input in the ObjectScript programming language. This can potentially lead to resource exhaustion or denial of service (DoS) attacks if an attacker is able to supply a very large input. \n\nIn the provided code snippet, the `read` command is used to get user input without any limit on the length of the input. This can potentially allow an attacker to cause a DoS attack by providing an extremely large input, causing the system to consume excessive resources trying to process the input.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to implement a length limit on the user input and perform downstream validation. This can be achieved by checking the length of the input after it is read and before it is processed. If the input exceeds the maximum allowed length, the program should reject the input and possibly alert the user that their input is too long.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\ndo {\n    read !, \"Name: \", name\n    if $length(name) > 100 { // assuming 100 is the maximum allowed length\n        write !, \"Input is too long. Please enter a name up to 100 characters.\"\n    } else {\n        return:(name = \"\") 0  // user entered nothing so return FALSE, exit loop AND method\n    }\n} While '..ValidName(name)\n```\n\nIn this fix, the length of the input is checked immediately after it is read. If the length exceeds 100 characters, the program writes an error message to the user and continues to the next iteration of the loop. If the length is within the allowed limit, the program proceeds as before.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## OWASP Resources and CWE\n\n- [OWASP - Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the above links are subject to change and may not be accessible to all users. Always ensure that the links are valid and active before adding them to the report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "3ed646f7-709c-3f10-a7ac-befa9871452f",
              "name": "\"READ Vulnerability Due to Lack of Length Limit: Suggest Adding #maxlen for Enhanced Security\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability is due to the lack of a length limit when reading user input in the ObjectScript programming language. This can lead to resource exhaustion or denial of service (DoS) if an attacker supplies a very large input. The vulnerability sink is in the `read` statement where the `dob` variable is read from the user without any length limit.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should enforce a limit on the length of the user input. This can be done by reading the input as usual, then checking the length of the input and discarding it if it exceeds the limit. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability sink:\n\n```objectscript\ndo {\n    read !, \"DOB: \", dob\n    if $length(dob) > 100 { // replace 100 with your desired maximum length\n        write !, \"Input is too long. Please enter a shorter DOB.\"\n    }\n} while '..ValidDOB(dob, .intdob)\n```\n\nThis fix reads the `dob` input as usual, then checks if its length exceeds 100 characters. If it does, it discards the input and asks the user to enter a shorter DOB. The loop then continues to the next iteration.\n\n## Library Dependencies\n\nThe code example does not appear to require any library dependencies to execute properly.\n\n## OWASP Resources and CWE\n\n- [OWASP Unrestricted File Upload](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the OWASP resource and CWE are in the context of the security finding, which is resource exhaustion or denial of service due to lack of input length limit. The links have been tested and are active and accessible to anonymous users."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "499a80f3-9d51-308a-a8b7-d54e1e77d26a",
              "name": "\"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability is related to the `READ` command in ObjectScript, which lacks a length limit. This can potentially lead to resource exhaustion or denial of service (DoS) attacks if an attacker is able to supply very large input. The `READ` command is used to get user input, and without a limit, it can consume excessive system resources. \n\nIn the provided code snippet, the `READ` command is used to get the date of birth (DOB) from the user. However, there is no limit on the length of the input, which makes it vulnerable to the aforementioned attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input after the `READ` command. This can be done by checking the length of the input and discarding it if it exceeds the maximum allowed length. \n\nAdditionally, it is important to validate the input downstream. In the provided code snippet, the `ValidDOB` function is used to validate the DOB. However, it is not clear whether this function checks the length of the input. It is recommended to ensure that this function also checks the length of the input.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\ndo {\n    read !, \"DOB: \", dob\n    if $LENGTH(dob)>50 {\n        write !, \"Input too long. Please enter a valid DOB.\"\n    }\n} While $LENGTH(dob)>50 || '..ValidDOB(dob, .intdob)\n```\n\nIn this fix, the length of the DOB is checked after the `READ` command. If the length exceeds 50 characters, an error message is displayed and the loop continues until a valid DOB is entered.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies.\n\n## OWASP Resources\n\n- [OWASP - Denial of Service](https://owasp.org/www-community/attacks/Denial_of_Service)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  },
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400",
                  "CWE-20"
                ]
              }
            },
            {
              "id": "5ec0f754-a889-33c5-965e-aa50f1b6348e",
              "name": "Potential Race Condition in Data Uniqueness Check with Separate Set Method: Consider Locking During Validate-Store Operation.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"Potential Race Condition in Data Uniqueness Check with Separate Set Method: Consider Locking During Validate-Store Operation\" refers to a situation where multiple processes are able to access and manipulate shared data concurrently. In the provided code snippet, the vulnerability arises when the code checks for the uniqueness of a phone number in the `^PersonI(\"Phone\", phone)` global. If two processes execute this code simultaneously with the same phone number, both could pass the uniqueness check and write the same phone number, leading to data inconsistency.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should implement a locking mechanism during the validate-store operation. This will ensure that only one process can access and manipulate the shared data at a time, preventing race conditions.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nlock +^PersonI(\"Phone\", phone):5 if $test {\n    if $data(^PersonI(\"Phone\", phone)) {\n        write !, \"Phone number already in use\"\n        lock -^PersonI(\"Phone\", phone)\n        return 0\n    }\n    // Store the phone number here\n    lock -^PersonI(\"Phone\", phone)\n} else {\n    write !, \"Unable to acquire lock\"\n    return 0\n}\n```\n\nIn this fix, the `lock` command is used to acquire a lock on the `^PersonI(\"Phone\", phone)` global. If the lock is successfully acquired, the code checks for the uniqueness of the phone number and stores it if it's unique. After the operation, the lock is released using the `lock -` command. If the lock cannot be acquired, the code returns an error message.\n\n## Library Dependencies\n\nThe provided code snippet does not require any library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\nNote: Always enforce authorization using IRIS security (resources/roles) and/or application authentication as a primary solution. This should be in addition to the proposed source code fix. In the source code fix recommendation, always use ObjectScript resource/privilege check via `$SYSTEM.Security.Check()` plus environment safeguards and real logging/auditing."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-362"
                ]
              }
            },
            {
              "id": "bf4b8989-114a-35f2-b7a6-e46ab8b15089",
              "name": "Consider using TSTART/TCOMMIT for consistency when multiple related SETs follow $INCREMENT outside transaction.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn InterSystems ObjectScript, the `$increment` function is used to atomically increment a global or local variable. However, when multiple related `SET` operations follow `$increment` outside a transaction, it can lead to inconsistencies. This is because `$increment` is atomic, but the subsequent `SET` operations are not. If an error occurs during one of the `SET` operations, or if another process modifies the data between the `SET` operations, the data can become inconsistent.\n\n## Mitigation\n\nTo mitigate this issue, you should use `TSTART` and `TCOMMIT` to wrap the `$increment` and related `SET` operations in a transaction. This ensures that all operations are either completed successfully or, in the case of an error, none of them are. This maintains the consistency of the data.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```objectscript\nTSTART\nset id = $increment(^PersonD)  // use $increment to generate a new ID\n// ... other related SET operations ...\nif $TLEVEL TCOMMIT\n```\n\nIn this code, `TSTART` begins a transaction. The `$increment` and related `SET` operations are then performed. If the transaction level (`$TLEVEL`) is greater than 0, indicating that a transaction is in progress, `TCOMMIT` is used to commit the transaction.\n\n## Library Dependencies\n\nThe provided code does not appear to have any library dependencies. It uses built-in functions of the ObjectScript language.\n\n## References\n\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-362"
                ]
              }
            },
            {
              "id": "b7d2889e-cb47-33e2-86e2-13bf33b98386",
              "name": "\"Unprotected Transaction Block Vulnerability without Error Handling\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\nThe vulnerability in the provided ObjectScript code is related to the lack of error handling in the transaction block. The code uses `tstart` to start a transaction and `tcommit` to commit the transaction, but it does not handle any potential errors that might occur during the transaction. If an error occurs, the transaction will be left in an undefined state, which could lead to data corruption or loss.\n\n## Mitigation Advice\nTo mitigate this vulnerability, it is recommended to use `trollback` in an error handling routine to rollback the transaction in case of an error. This ensures that the database remains in a consistent state even if an error occurs during the transaction.\n\n## Source Code Fix Recommendation\nHere is a recommended fix for the provided code:\n\n```objectscript\ntstart\ntry {\n  set ^PersonD(id) = answers  // store the answers\n\n  set $listbuild(name, phone, intdob) = answers\n  // split name into last and first for storage in index\n  set last = $piece(name, \",\", 1), first = $piece(name, \",\", 2)\n\n  /* the next three statements store data in subscripts.\n  because of the automatic sorting of subscripts,\n  this has the effect of building 3 indices: name, phone, and DOB */\n  set ^PersonI(\"Name\", last, first, id) = \"\"  // index last and first name\n  set ^PersonI(\"Phone\", phone) = id           // index the UNIQUE phone\n  set ^PersonI(\"DOB\", intdob, id) = \"\"        // index the internal DOB\n\n  /* these statements turn the id into a \"chunk #\" and a \"position #\"\n  and set a bit into the bitmap index */\n  set chunk = (id\\64000) + 1, position = (id#64000) + 1\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 1\n  tcommit\n} catch {\n  trollback\n  // handle the error, e.g., log it and/or notify the user\n}\n```\n\nThis code uses a `try`/`catch` block to handle any errors that might occur during the transaction. If an error occurs, the `catch` block is executed, which rolls back the transaction and then handles the error.\n\n## Library Dependencies\nThe provided code does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n- [CWE-391: Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This should be added/appended to the proposed source code fix recommendation."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-391",
                    "url": "https://cwe.mitre.org/data/definitions/391.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-391"
                ]
              }
            },
            {
              "id": "01879d89-0731-3f2d-8f28-222b8397169c",
              "name": "\"Global Root Deletion: Admin-Only Access, Not for Production Use\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"Global Root Deletion: Admin-Only Access, Not for Production Use\" in ObjectScript programming language refers to the situation where an application allows deletion of global root data structures without proper access control. This can lead to unauthorized data manipulation or deletion, potentially causing data loss or corruption.\n\nIn the provided code example, the `kill` command is used to delete the global root data structures `^PersonD` and `^PersonI` without any checks for user permissions or roles.\n\n```objectscript\nkill ^PersonD, ^PersonI\n```\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper access control mechanisms. This includes checking the user's roles and permissions before allowing them to perform sensitive operations such as deleting global root data structures.\n\nIn addition to implementing access control in the source code, it is also important to enforce authorization using IRIS security (resources/roles) and/or application authentication. This should be the primary solution for dealing with access control issues.\n\n## Source Code Fix Recommendation\n\nThe following code snippet demonstrates how to check user roles before deleting global root data structures. It uses the `$SYSTEM.Security.Check()` method to verify if the current user has the 'Admin' role.\n\n```objectscript\nif $SYSTEM.Security.Check(\"Admin\", \"%Admin_Manage\") {\n    kill ^PersonD, ^PersonI\n} else {\n    write \"Insufficient privileges to perform this operation.\",!\n    return 0\n}\n```\n\nThis code will only delete the `^PersonD` and `^PersonI` global root data structures if the current user has the 'Admin' role. If the user does not have the required role, the operation will not be performed and an error message will be displayed.\n\n## References\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that the provided links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "4d0c456f-a42e-311e-b69e-14311e702bb7",
              "name": "\"Admin-Only Restriction Required for Detected Extent Deletion Vulnerability\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"Admin-Only Restriction Required for Detected Extent Deletion Vulnerability\" in ObjectScript programming language refers to a situation where an unauthorized user can delete an entire extent (all instances of a class) by invoking the `%KillExtent()` method. This can lead to data loss and potential disruption of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to implement access control checks before executing the `%KillExtent()` method. This can be done by checking the user's role and ensuring that only users with administrative privileges can execute this method. \n\n## Source Code Fix Recommendation\n\nHere is a sample code fix that checks if the current user has the 'Admin' role before executing the `%KillExtent()` method:\n\n```objectscript\nset userRole = $SYSTEM.Security.Login(\"\", \"\", \"%Admin\")\nif userRole {\n    do ##class(ObjectScript.Person).%KillExtent()\n} else {\n    write \"You do not have the necessary permissions to perform this action.\"\n    return 0\n}\n```\n\nIn this code, `$SYSTEM.Security.Login(\"\", \"\", \"%Admin\")` checks if the current user has the 'Admin' role. If the user has the 'Admin' role, the `%KillExtent()` method is executed. If not, a message is displayed to the user and the method returns 0.\n\nNote: This code fix should be used in conjunction with IRIS security (resources/roles) and/or application authentication for enforcing authorization. \n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Access Control Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that these links are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "1f4724ef-1c72-3b83-aac4-2e58ac0c7a18",
              "name": "\"READ validation lacks length limit despite pattern match\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the lack of input length validation in the `READ` command of the ObjectScript programming language. The `READ` command is used to get user input, and in this case, it does not have a limit on the length of the input. This can lead to resource exhaustion or denial of service (DoS) attacks if an attacker provides a very large input. \n\nThe code snippet provided uses a regular expression to validate the format of the input, but it does not limit the length of the input. This means that even if the input matches the pattern, it can still be excessively long and cause issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input after the `READ` command. This can be done by checking the length of the input and returning an error if it exceeds the limit. \n\nIt is also important to note that authorization should be enforced using IRIS security (resources/roles) and/or application authentication. This should be the primary solution, and the code fix is a secondary measure to prevent misuse.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```objectscript\nread !, \"Lookup: \", lookup\nreturn:(lookup = \"\") 0  // user entered nothing so return FALSE\nif $length(lookup) > 12 {\n    write !, \"Input too long. Please enter a maximum of 12 characters.\"\n    return 0\n}\nif (lookup = \"?\") {\n    set type = \"help\", search = \"\"\n}\n// the RegEx accepts ###- or ###-###-#### only\nelseif $match(lookup, \"\\d{3}-(\\d{3}-\\d{4})?\") {\n    // rest of the code\n}\n```\n\nThis code checks the length of the input and returns an error if it exceeds 12 characters. The number 12 is chosen based on the maximum length of the input format specified by the regular expression.\n\n## Library Dependencies\n\nThe code does not seem to require any specific library dependencies to execute properly.\n\n## OWASP and CWE Resources\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "e4b58409-487c-3a5f-93f3-358dcf66133a",
              "name": "\"READ validation lacks length limit despite pattern match\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the lack of input length validation in the `READ` command of the ObjectScript programming language. The `READ` command is used to get user input, and in this case, it does not have a limit on the length of the input. This can lead to resource exhaustion or denial of service (DoS) attacks if an attacker provides a very large input. \n\nThe code snippet provided uses a regular expression to validate the format of the input, but it does not limit the length of the input. This means that even if the input matches the pattern, it can still be excessively long and cause issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input after the `READ` command. This can be done by checking the length of the input and returning an error if it exceeds the limit. \n\nIt is also important to note that authorization should be enforced using IRIS security (resources/roles) and/or application authentication. This should be the primary solution, and the code fix is a secondary measure to prevent misuse.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```objectscript\nread !, \"Lookup: \", lookup\nreturn:(lookup = \"\") 0  // user entered nothing so return FALSE\nif $length(lookup) > 12 {\n    write !, \"Input too long. Please enter a maximum of 12 characters.\"\n    return 0\n}\nif (lookup = \"?\") {\n    set type = \"help\", search = \"\"\n}\n// the RegEx accepts ###- or ###-###-#### only\nelseif $match(lookup, \"\\d{3}-(\\d{3}-\\d{4})?\") {\n    // rest of the code\n}\n```\n\nThis code checks the length of the input and returns an error if it exceeds 12 characters. The number 12 is chosen based on the maximum length of the input format specified by the regular expression.\n\n## Library Dependencies\n\nThe code does not seem to require any specific library dependencies to execute properly.\n\n## OWASP and CWE Resources\n\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400"
                ]
              }
            },
            {
              "id": "29ee34b7-ccf0-30dd-b66b-6f7bc6735d1b",
              "name": "\"Vulnerability in Transaction Block without Error Handling using Try/Catch and TROLLBACK\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe provided ObjectScript code block is vulnerable due to the lack of error handling. The code block starts a transaction, performs several operations, and then commits the transaction. If any of these operations fail, the transaction will be left in an inconsistent state. This can lead to data corruption or loss, and can potentially be exploited by an attacker to cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, the code should include error handling to ensure that if any operation within the transaction fails, the transaction is rolled back to its initial state. This can be achieved using the `try/catch` construct and the `TROLLBACK` command.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code block:\n\n```objectscript\ntstart\ntry {\n  kill ^PersonD(id)\n  kill ^PersonI(\"Name\", last, first, id)\n  kill ^PersonI(\"Phone\", phone)\n  kill ^PersonI(\"DOB\", intdob, id)\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 0\n  tcommit\n} catch {\n  trollback\n  // Log the error for debugging purposes\n  write \"Error: \", $system.Status.GetErrorText($ZERROR),!\n  // Return or throw the error to the caller\n  quit\n}\n```\n\nThis code will start a transaction, perform the operations, and commit the transaction. If any operation fails, it will catch the error, roll back the transaction, log the error, and then quit the execution.\n\n## Library Dependencies\n\nThe provided code does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP Error Handling](https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html)\n- [CWE-391: Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391.html)\n\nPlease note that enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This can be achieved using the `$SYSTEM.Security.Check()` function in ObjectScript."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-391",
                    "url": "https://cwe.mitre.org/data/definitions/391.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-391"
                ]
              }
            },
            {
              "id": "20132af7-7e3c-31be-bd4f-af6dee00c8e0",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability lies in the lack of proper authorization verification before deleting a global node in the ObjectScript programming language. The code `kill ^PersonI(\"Name\", last, first, id)` deletes a global node without checking if the user has the necessary permissions to perform this action. This could potentially allow unauthorized users to delete important data.\n\nMoreover, the code does not maintain referential/index consistency. Deleting a global node without ensuring that all references to it are also deleted can lead to inconsistencies in the data and may cause errors in the future.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before performing any action that modifies data. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript. \n\nIn addition, it is important to maintain referential/index consistency when deleting global nodes. This can be achieved by ensuring that all references to a node are also deleted when the node itself is deleted.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```objectscript\nset resource = \"%%ResourceName%%\"\nset permission = \"W\"\nset access = $SYSTEM.Security.Check(resource, permission)\nif 'access {\n    write \"You do not have the necessary permissions to perform this action.\"\n    quit\n}\nkill ^PersonI(\"Name\", last, first, id)\n```\n\nIn this code, `resource` should be replaced with the actual resource name and `permission` should be replaced with the actual permission name. The `$SYSTEM.Security.Check()` function checks if the user has the necessary permissions to perform the action. If the user does not have the necessary permissions, the function returns 0 and the code writes an error message and quits.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This source code fix is a secondary measure to ensure security.\n\n## References\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that the links provided are active and accessible to anonymous users."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "72d80781-e079-3971-b3e2-6b71b145a3f1",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability lies in the lack of authorization verification before deleting a global node in the ObjectScript programming language. This could allow an unauthorized user to delete data they should not have access to, leading to data loss or corruption. Additionally, there is no referential or index consistency maintenance after the deletion, which could lead to inconsistencies in the database.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before performing any deletion operation. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript. Additionally, after deleting a node, it is important to maintain referential and index consistency to ensure the integrity of the database.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix that includes an authorization check before deletion and a function call to maintain consistency after deletion:\n\n```objectscript\nset resourceId = \"%%resource:id%%\"\nif '$SYSTEM.Security.Check(resourceId, \"%Delete\") {\n    write \"You do not have permission to delete this record.\",!\n    return 0\n}\nkill ^PersonD(id)\ndo maintainConsistency(id)\n```\n\nIn this code, `resourceId` should be replaced with the actual resource ID associated with the deletion operation. The `maintainConsistency` function should be implemented to handle referential and index consistency after deletion.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This source code fix is a secondary measure to ensure security at the code level.\n\n## Library Dependencies\n\nThe code example does not require any external library dependencies to execute properly.\n\n## OWASP and CWE Resources\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n\nPlease note that the links provided are active and accessible to anonymous users."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285"
                ]
              }
            },
            {
              "id": "1c63cc4b-0cc5-3298-8eb0-523a47135950",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question pertains to the lack of proper authorization verification and referential/index consistency maintenance when deleting a global node in the ObjectScript programming language. In the provided code snippet, the `kill` command is used to delete a node from the `^PersonI(\"DOB\", intdob, id)` global array without any checks for user permissions or referential integrity. This could potentially allow unauthorized users to delete data they shouldn't have access to, or cause inconsistencies in the data by deleting nodes that are still being referenced elsewhere in the application.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to implement proper authorization checks before allowing a user to delete a node. This can be done using the `$SYSTEM.Security.Check()` method provided by InterSystems ObjectScript. Additionally, referential integrity should be maintained by checking if the node being deleted is still being referenced elsewhere in the application.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```objectscript\nset resource = \"PersonI\"\nset permission = \"W\"\n\nif '$SYSTEM.Security.Check(resource, permission) {\n    write \"You do not have the necessary permissions to delete this node.\", !\n    return 0\n}\n\nif $data(^PersonI(\"DOB\", intdob, id)) {\n    // Check for references to this node elsewhere in the application\n    // If no references are found, proceed with deletion\n    kill ^PersonI(\"DOB\", intdob, id)\n} else {\n    write \"Node does not exist or is already deleted.\", !\n    return 0\n}\n```\n\nNote: This code fix is only part of the solution. Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. \n\n## References\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "80e5bcc0-bd1f-325f-881b-f661c4d44193",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability lies in the lack of proper authorization verification before deleting a global node in the ObjectScript programming language. The code `kill ^PersonI(\"Phone\", phone)` deletes a global node without checking if the user has the necessary permissions to perform this action. This could potentially allow unauthorized users to delete important data.\n\nMoreover, the code does not maintain referential/index consistency. Deleting a global node without ensuring that all references to it are also deleted can lead to inconsistencies in the data and may cause errors in the future.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before performing any action that modifies the data. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript. \n\nAdditionally, maintaining referential/index consistency is also important. Before deleting a global node, make sure to delete all references to it.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```objectscript\nset resource = \"%%ResourceName%%\"\nset permission = \"RW\"\nset access = $SYSTEM.Security.Check(resource, permission)\nif 'access {\n    write \"Access denied\",!\n    return 0\n}\nkill ^PersonI(\"Phone\", phone)\n```\n\nIn this code, `resource` should be replaced with the actual resource name and `permission` should be replaced with the required permission level. The `$SYSTEM.Security.Check()` function checks if the current user has the necessary permissions to perform the action. If the user does not have the necessary permissions, the function returns 0 and the code execution is stopped.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This source code fix is a secondary measure to ensure that only authorized users can delete global nodes.\n\n## References\n\n- [OWASP Top 10 - A5:2017-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "1796d0d6-cb26-353c-bf29-b10f6a8320b8",
              "name": "\"Unprotected Transaction Block Vulnerability with Error Handling via Try/Catch and TROLLBACK\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe code snippet provided is vulnerable to an \"Unprotected Transaction Block Vulnerability with Error Handling via Try/Catch and TROLLBACK\". This vulnerability occurs when a transaction block is not properly protected with error handling mechanisms. In the event of an error within the transaction block, the transaction may not be properly rolled back, leading to inconsistent data states.\n\nIn the provided code, the transaction block starts with `tstart` and ends with `tcommit`. However, there is no error handling mechanism in place to ensure that the transaction is rolled back in case of an error. This could lead to data inconsistency if an error occurs during the transaction.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a `try/catch` block to handle any errors that may occur during the transaction. If an error is caught, the transaction should be rolled back using `trollback`. This ensures that the database remains in a consistent state even if an error occurs during the transaction.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```objectscript\ntstart\ntry {\n  set ^PersonD(id) = newanswers\n  if (newname '= currentname) {\n    // kill old name and add new name to index\n    kill ^PersonI(\"Name\", currentlast, currentfirst, id)\n    set ^PersonI(\"Name\", newlast, newfirst, id) = \"\"\n  }\n  if (newphone '= currentphone) {\n    // kill old phone and add new phone to index\n    kill ^PersonI(\"Phone\", currentphone)\n    set ^PersonI(\"Phone\", newphone) = id\n  }\n  if (newintdob '= currentintdob) {\n    // kill old dob and add new dob to index\n    kill ^PersonI(\"DOB\", currentintdob, id)\n    set ^PersonI(\"DOB\", newintdob, id) = \"\"\n  }\n  tcommit  // commit the transaction\n} catch {\n  trollback  // rollback the transaction in case of an error\n}\n```\n\nThis code now includes a `try/catch` block that wraps the transaction. If an error occurs during the transaction, the `catch` block is executed, which rolls back the transaction using `trollback`.\n\n## Library Dependencies\n\nThe provided code does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP - Error Handling](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n- [CWE-460: Improper Cleanup on Thrown Exception](https://cwe.mitre.org/data/definitions/460.html)\n\nNote: Always ensure to enforce authorization using IRIS security (resources/roles) and/or application authentication as a primary solution. This should be in addition to the proposed solution in the source code."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-460",
                    "url": "https://cwe.mitre.org/data/definitions/460.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-460"
                ]
              }
            },
            {
              "id": "8ce05a7d-fb70-3819-9558-f376f862e78e",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability lies in the lack of proper authorization verification before deleting a node in the global array `^PersonI(\"Name\", currentlast, currentfirst, id)`. This could potentially allow unauthorized users to delete data they should not have access to. Additionally, there is no referential or index consistency maintenance, which could lead to orphaned records or inconsistent data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before performing any deletion operation. This can be achieved by using the `$SYSTEM.Security.Check()` method to verify if the current user has the necessary privileges to perform the deletion. \n\nMoreover, it is important to maintain referential and index consistency when deleting data. This can be done by implementing checks to ensure that no orphaned records are left behind and that all indexes are updated accordingly after the deletion.\n\n## Source Code Fix Recommendation\n\n```objectscript\nset resource = \"PersonI\"\nset permission = \"W\"\nset access = $SYSTEM.Security.Check(resource, permission)\nif 'access {\n    write \"You do not have the necessary permissions to perform this operation.\",!\n    return 0\n}\n\n// Perform referential/index consistency checks before deletion\n// ...\n\nkill ^PersonI(\"Name\", currentlast, currentfirst, id)\n```\n\nIn addition to the source code fix, enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This includes setting up appropriate user roles and permissions in the IRIS security settings and ensuring that users are properly authenticated before they can perform any operations.\n\n## References\n\n- [OWASP Top 10-2017 A5-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "5a8eaf42-0bfb-34db-9b94-e596fca1725d",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability lies in the lack of proper authorization verification and referential/index consistency maintenance when deleting a global node in the ObjectScript programming language. The specific vulnerability sink is the `kill ^PersonI(\"Phone\", currentphone)` command, which deletes the global node without checking if the user has the necessary permissions to perform this action. This could potentially allow unauthorized users to delete important data. Additionally, this command does not maintain referential/index consistency, which could lead to data inconsistency issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before performing any action that could modify the data. This can be done using the `$SYSTEM.Security.Check()` function in ObjectScript, which checks if the current user has the necessary permissions to perform the action. Additionally, it is important to maintain referential/index consistency when deleting a global node. This can be done by ensuring that all references to the node are also deleted or updated accordingly.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```objectscript\nset resource = \"%%resource%%\"\nset permission = \"RW\"\nset result = $SYSTEM.Security.Check(resource, permission)\nif 'result {\n    write \"You do not have the necessary permissions to perform this action.\"\n    quit\n}\n// Ensure referential/index consistency\n// Code to update/delete all references to the node\nkill ^PersonI(\"Phone\", currentphone)\n```\n\nNote: Always enforce authorization using IRIS security (resources/roles) and/or application authentication as the primary solution. This should be in addition to the source code fix.\n\n## References\n\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "33f20dda-eb54-3410-96f5-2d82070864bf",
              "name": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability lies in the lack of proper authorization verification before deleting a global node in the ObjectScript programming language. The code `kill ^PersonI(\"DOB\", currentintdob, id)` deletes a global node without checking if the user has the necessary permissions to perform this action. This could lead to unauthorized data manipulation or data loss.\n\nMoreover, the code does not maintain referential/index consistency. Deleting a node without ensuring that no other parts of the program are referencing it can lead to inconsistencies in the data and may cause the program to behave unexpectedly or crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is crucial to implement proper authorization checks before performing any action that could modify data. This includes deleting global nodes. The authorization checks should verify if the user has the necessary permissions to perform the action.\n\nIn addition, it is important to maintain referential/index consistency when deleting nodes. This can be achieved by checking if the node is being referenced elsewhere in the program before deleting it.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability:\n\n```objectscript\nif $SYSTEM.Security.Check(\"Permission to delete node\", \"%Admin_Manage\") {\n    if $data(^PersonI(\"DOB\", currentintdob, id)) {\n        kill ^PersonI(\"DOB\", currentintdob, id)\n    } else {\n        write \"Node does not exist or is already deleted.\",!\n        return 0\n    }\n} else {\n    write \"You do not have the necessary permissions to delete this node.\",!\n    return 0\n}\n```\n\nThis code first checks if the user has the necessary permissions to delete the node. If they do, it then checks if the node exists before deleting it. If the node does not exist, it informs the user and exits the function.\n\nNote: Enforcing authorization using IRIS security (resources/roles) and/or application authentication should be the primary solution. This note should be added/appended to the proposed source code fix recommendation.\n\n## References\n\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-362",
                    "url": "https://cwe.mitre.org/data/definitions/362.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-362"
                ]
              }
            },
            {
              "id": "54211a2f-95e9-3e07-897e-253a1bd9dc64",
              "name": "\"READ lacks length limit and downstream validation: Consider #maxlen for enhanced security.\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability is related to the lack of length limit and downstream validation in the `READ` command in ObjectScript. The `READ` command is used to get user input, but without a length limit, an attacker could potentially cause a Denial of Service (DoS) attack by providing an extremely large input, leading to resource exhaustion.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a length limit and downstream validation on the user input. This can be achieved by using the `#maxlen` option in the `READ` command, which specifies the maximum number of characters to read. After reading the input, further validation should be performed to ensure the input meets the expected format and constraints.\n\n## Source Code Fix Recommendation\n\n```objectscript\ndo {\n    read !, \"Phone (617): \", phone#30\n    if $LENGTH(phone) > 30 {\n        write !, \"Input too long. Please enter a phone number with up to 30 characters.\"\n    }\n} While '..ValidPhone(.phone)\n```\n\nIn the above code, `#30` is added to the `READ` command to limit the input length to 30 characters. After reading the input, it checks if the length of the input exceeds 30 characters. If it does, it prompts the user to enter a shorter phone number.\n\n## Library Dependencies\n\nThe code example does not appear to require any specific library dependencies to execute properly.\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion')](https://cwe.mitre.org/data/definitions/400.html)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  },
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400",
                  "CWE-20"
                ]
              }
            },
            {
              "id": "a812b057-eba4-3975-85d0-6cb81435013b",
              "name": "\"READ Lacks Length Limit and Requires Downstream Validation: Consider Implementing #maxlen for Enhanced Security\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability is related to the lack of input length limit in the `read` function in ObjectScript. This can potentially lead to resource exhaustion or denial of service (DoS) attacks if an attacker is able to supply a very large input. The `read` function is used to get user input, and in this case, it is used to get a phone number. However, there is no limit on the length of the phone number that can be entered, which is a security concern.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to enforce a limit on the length of the input after the `read` function. This can be done by checking the length of the input and rejecting it if it exceeds a certain limit. Additionally, it is also recommended to validate the input downstream to ensure that it meets the required format and criteria.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```objectscript\ndo {\n    read !, \"Phone (617): \", phone\n    if $length(phone) > 15 {\n        write !, \"Phone number is too long. Please enter a valid phone number.\"\n    }\n} while '..ValidPhone(.phone) || $length(phone) > 15\n```\n\nIn this fix, the length of the phone number is checked after it is read. If it exceeds 15 characters (which is the maximum length for a phone number including country code), a message is displayed to the user and the loop continues until a valid phone number of acceptable length is entered.\n\n## Library Dependencies\n\nThe code example does not appear to have any library dependencies.\n\n## OWASP Resources\n\n- [OWASP Top 10-2017 A3-Sensitive Data Exposure](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-400",
                    "url": "https://cwe.mitre.org/data/definitions/400.html"
                  },
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-400",
                  "CWE-20"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "cafcafb1-54e4-3005-a9fe-3fd052454113",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry1.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 1,
                  "endLine": 8,
                  "endColumn": 27,
                  "snippet": {
                    "text": "  read !, \"Phone: \", phone"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e826f109c4b45f10eee9761c945719176bc6b4aa43aa8b528eecb0f23972e1e9",
            "glog-pfp-ruleFileCode/v1": "4d988c25ff43dbdbaf7a05cd1696f869fd7cba05aa4552c4982d3b4e94de80dd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "4d988c25ff43dbdbaf7a05cd1696f869fd7cba05aa4552c4982d3b4e94de80dd"
          },
          "properties": {}
        },
        {
          "ruleId": "dde36b30-4084-3114-9c88-74272d0a459d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry1.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 1,
                  "endLine": 10,
                  "endColumn": 1,
                  "snippet": {
                    "text": "  read !, \"DOB: \", dob"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "a16517c0f7a1862ad00bed6bab01410c3c653d18c2f71619a8ffc6c248854784",
            "glog-pfp-ruleFileCode/v1": "f18002dcec8b804fc4aff86ddc75b0318e4aa913b880f394fc091504f48d1af0"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f18002dcec8b804fc4aff86ddc75b0318e4aa913b880f394fc091504f48d1af0"
          },
          "properties": {}
        },
        {
          "ruleId": "29b13a5d-59a3-3bdc-bf3b-705753a4df6b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry1.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 1,
                  "endLine": 6,
                  "endColumn": 26,
                  "snippet": {
                    "text": "  read !, \"Name: \" , name"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1eb0a19967bdf3a84b461d73a43ca1d67a24b112574176098cd2c9bc56d8ec1f",
            "glog-pfp-ruleFileCode/v1": "9a56055f23c0da538635528a49f93c4c2289ddec20bf6ba59bf5a8760bbe5f4e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9a56055f23c0da538635528a49f93c4c2289ddec20bf6ba59bf5a8760bbe5f4e"
          },
          "properties": {}
        },
        {
          "ruleId": "435010c9-558e-3363-b9d6-0240e98604bb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 1,
                  "endLine": 15,
                  "endColumn": 25,
                  "snippet": {
                    "text": "  read !, \"Name: \", name"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1588fd68e296aefb65029f3ddd8a6aa0477c00f7d05c9f86e8e3ac695b8f4a04",
            "glog-pfp-ruleFileCode/v1": "c106970a3015e1768d0c46da207f0b746f250550d6e18743983cea2298ec866b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c106970a3015e1768d0c46da207f0b746f250550d6e18743983cea2298ec866b"
          },
          "properties": {}
        },
        {
          "ruleId": "4e6b4276-0f0e-32cd-8208-0994f0e7ce53",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 1,
                  "endLine": 18,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  read !, \"DOB: \", dob"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5751a49c2db36846c77ea9f6320c4c2775bf22601f0d6786d67653555592de83",
            "glog-pfp-ruleFileCode/v1": "f68b5162038558ce480a5a02eef7addf417debda8710a3a71119858aab2e0b0c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f68b5162038558ce480a5a02eef7addf417debda8710a3a71119858aab2e0b0c"
          },
          "properties": {}
        },
        {
          "ruleId": "6c9216c5-1199-3e3d-be32-76444508b497",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unrestricted Read Length or Lack of Input Validation Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 1,
                  "endLine": 17,
                  "endColumn": 27,
                  "snippet": {
                    "text": "  read !, \"Phone: \", phone"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f88fed0aa0791482ac2ccafcd80ab66c6fd9df6132b217e52ac397e114e40ec3",
            "glog-pfp-ruleFileCode/v1": "bdb55c573e4c113c915bdee6240a0a5f7481ccdaf9736a6b7f6b9901f2e6ef18"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "bdb55c573e4c113c915bdee6240a0a5f7481ccdaf9736a6b7f6b9901f2e6ef18"
          },
          "properties": {}
        },
        {
          "ruleId": "cd5c0c9e-441e-3ab5-ae94-990b4540352a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Vulnerability: No Length Limit and Lacks Downstream Validation - Suggest Adding #maxlen for Enhanced Security\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 3,
                  "endLine": 18,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"Name: \", name\n    return:(name = \"\") 0  // user entered nothing so return FALSE, exit loop AND method\n  } while '..ValidName(name)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "88330178e5906f5a327710de523a76fc6012996262e842edc3d3ef9e40b52042",
            "glog-pfp-ruleFileCode/v1": "72f9cb269d60974d2dec07781c8313d932a75856831e71295bf90cefa4d10a8a"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "72f9cb269d60974d2dec07781c8313d932a75856831e71295bf90cefa4d10a8a"
          },
          "properties": {}
        },
        {
          "ruleId": "42493282-59f2-325f-a414-89b76af33cf1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ lacks length limit and downstream validation, consider implementing #maxlen for enhanced security.\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 3,
                  "endLine": 19,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"Name: \", name\n    return:(name = \"\") 0  // user entered nothing so return FALSE, exit loop AND method\n  } While '..ValidName(name)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "a26a27f1f7759a90be695423e71456f39c405514740fb649ed46101e1f4cce8a",
            "glog-pfp-ruleFileCode/v1": "b7eef19b46d93b7571a649686a9292b219f18d52d1f86e4406b849c6e49c91f1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "b7eef19b46d93b7571a649686a9292b219f18d52d1f86e4406b849c6e49c91f1"
          },
          "properties": {}
        },
        {
          "ruleId": "3ed646f7-709c-3f10-a7ac-befa9871452f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Vulnerability Due to Lack of Length Limit: Suggest Adding #maxlen for Enhanced Security\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 3,
                  "endLine": 26,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"DOB: \", dob\n  } while '..ValidDOB(dob, .intdob)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e6d0ee4d2d6533856c3de647e91454b57aa63cb689353fc9e354fd62284dafac",
            "glog-pfp-ruleFileCode/v1": "94dc920180ff2b72d37f7c85a52814c9cf11f1d1042a584c14a23c0cc8b7f587"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "94dc920180ff2b72d37f7c85a52814c9cf11f1d1042a584c14a23c0cc8b7f587"
          },
          "properties": {}
        },
        {
          "ruleId": "499a80f3-9d51-308a-a8b7-d54e1e77d26a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Lacks Length Limit and Requires Downstream Validation: Consider #maxlen for Enhanced Security\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 3,
                  "endLine": 27,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"DOB: \", dob\n  } While '..ValidDOB(dob, .intdob)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "12d7de5090d32ba81c31cd35728ebdb7f7dae490f24ead4f33f52990efc9ff5f",
            "glog-pfp-ruleFileCode/v1": "eace1c7a8f7c366eb78748ab636f9891fd378660c60dd6167f5e8b1c77ed71cd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "eace1c7a8f7c366eb78748ab636f9891fd378660c60dd6167f5e8b1c77ed71cd"
          },
          "properties": {}
        },
        {
          "ruleId": "5ec0f754-a889-33c5-965e-aa50f1b6348e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential Race Condition in Data Uniqueness Check with Separate Set Method: Consider Locking During Validate-Store Operation."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 5,
                  "endLine": 56,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    if $data(^PersonI(\"Phone\", phone)) {\n      write !, \"Phone number already in use\"\n      return 0"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "d9ffcb402aaefee9aafdeb7fbd1e0302b89f01ce1dc7e0ae4d276782c216d4ae",
            "glog-pfp-ruleFileCode/v1": "3380a87a09c4db7b2f36452d037308798a281171de8ab560de6475418f15d5dd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3380a87a09c4db7b2f36452d037308798a281171de8ab560de6475418f15d5dd"
          },
          "properties": {}
        },
        {
          "ruleId": "bf4b8989-114a-35f2-b7a6-e46ab8b15089",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Consider using TSTART/TCOMMIT for consistency when multiple related SETs follow $INCREMENT outside transaction."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 1,
                  "endLine": 110,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n  set id = $increment(^PersonD)  // use $increment to generate a new ID"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "8b24776f23797e5a44e106662418a1549d9214b4c7ac7baeb8a2c6f3ab9e3afd",
            "glog-pfp-ruleFileCode/v1": "135fdad62d87be0a6f530642f119c099171187f5db1c23973e0728a2ad18667c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "135fdad62d87be0a6f530642f119c099171187f5db1c23973e0728a2ad18667c"
          },
          "properties": {}
        },
        {
          "ruleId": "b7d2889e-cb47-33e2-86e2-13bf33b98386",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Unprotected Transaction Block Vulnerability without Error Handling\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 3,
                  "endLine": 130,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  tstart\n  set ^PersonD(id) = answers  // store the answers\n\n  set $listbuild(name, phone, intdob) = answers\n  // split name into last and first for storage in index\n  set last = $piece(name, \",\", 1), first = $piece(name, \",\", 2)\n\n\t/* the next three statements store data in subscripts.\n  because of the automatic sorting of subscripts,\n  this has the effect of building 3 indices: name, phone, and DOB */\n  set ^PersonI(\"Name\", last, first, id) = \"\"  // index last and first name\n  set ^PersonI(\"Phone\", phone) = id           // index the UNIQUE phone\n  set ^PersonI(\"DOB\", intdob, id) = \"\"        // index the internal DOB\n\n\t/* these statements turn the id into a \"chunk #\" and a \"position #\"\n  and set a bit into the bitmap index */\n  set chunk = (id\\64000) + 1, position = (id#64000) + 1\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 1\n  tcommit"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5b7be2c20a33b3d2a258344cb731f430ec11b3ddbc054b69dab7828a318fe75c",
            "glog-pfp-ruleFileCode/v1": "8205c180161f40bf01a292183503ab96dd94245da5f906dd4b394539173317d8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8205c180161f40bf01a292183503ab96dd94245da5f906dd4b394539173317d8"
          },
          "properties": {}
        },
        {
          "ruleId": "472c15e6-ffcc-3a94-8295-65e61fb52e2d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Data Reset Pattern Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 1,
                  "endLine": 137,
                  "endColumn": 9,
                  "snippet": {
                    "text": "ClassMethod Load()\n{\n  kill ^PersonD, ^PersonI"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e46d2a30aa0d31f66fc3c4492caeab96a9e23b5f5e3d2441fd797183e8a8944b",
            "glog-pfp-ruleFileCode/v1": "2c9e244929f3b8095ba97e90535f6a3b94412ed8b8caf76810149bf00d84ef9f"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2c9e244929f3b8095ba97e90535f6a3b94412ed8b8caf76810149bf00d84ef9f"
          },
          "properties": {}
        },
        {
          "ruleId": "01879d89-0731-3f2d-8f28-222b8397169c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Global Root Deletion: Admin-Only Access, Not for Production Use\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 137,
                  "startColumn": 1,
                  "endLine": 137,
                  "endColumn": 26,
                  "snippet": {
                    "text": "  kill ^PersonD, ^PersonI"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f7acc2d8fb698b79dbe5f1419cfb25ea127a904bf8965d4259905f2cd4f7f53e",
            "glog-pfp-ruleFileCode/v1": "71bf54ba2a9144e1b91e28200b017cdf95ff6c26b1370006bc6cd7ee99d51ff9"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "71bf54ba2a9144e1b91e28200b017cdf95ff6c26b1370006bc6cd7ee99d51ff9"
          },
          "properties": {}
        },
        {
          "ruleId": "4d0c456f-a42e-311e-b69e-14311e702bb7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Admin-Only Restriction Required for Detected Extent Deletion Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 35,
                  "endLine": 138,
                  "endColumn": 47,
                  "snippet": {
                    "text": "  do ##class(ObjectScript.Person).%KillExtent()"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "85887d486731a3fbc39cb1daf9906e7d01cc348c959a812be3eef71a9837b677",
            "glog-pfp-ruleFileCode/v1": "4490d8d8e00d0a76642c1ef08ef845f36dc24664bbc7b8c452933a22ce1968a3"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "4490d8d8e00d0a76642c1ef08ef845f36dc24664bbc7b8c452933a22ce1968a3"
          },
          "properties": {}
        },
        {
          "ruleId": "1f4724ef-1c72-3b83-aac4-2e58ac0c7a18",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ validation lacks length limit despite pattern match\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup2.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 1,
                  "endLine": 26,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  read !, \"Lookup: \", lookup\n  return:(lookup = \"\") 0  // user entered nothing so return FALSE\n  if (lookup = \"?\") {\n    set type = \"help\", search = \"\"\n  }\n  // the RegEx accepts ###- or ###-###-#### only\n  elseif $match(lookup, \"\\d{3}-(\\d{3}-\\d{4})?\") {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c369cf38a9c01c51c8e1910e8f167d7748ea16733959a50b230ad1163fe5857e",
            "glog-pfp-ruleFileCode/v1": "50697fdb20a31b2a0f51c7ac791d19a58529da92d4791f879ba2e621eaf0936d"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "50697fdb20a31b2a0f51c7ac791d19a58529da92d4791f879ba2e621eaf0936d"
          },
          "properties": {}
        },
        {
          "ruleId": "e4b58409-487c-3a5f-93f3-358dcf66133a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ validation lacks length limit despite pattern match\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 1,
                  "endLine": 26,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  read !, \"Lookup: \", lookup\n  return:(lookup = \"\") 0  // user entered nothing so return FALSE\n  if (lookup = \"?\") {\n    set type = \"help\", search = \"\"\n  }\n  // the RegEx accepts ###- or ###-###-#### only\n  elseif $match(lookup, \"\\d{3}-(\\d{3}-\\d{4})?\") {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7ebb7b591794a34ddfcee13e44218813c1fd694d9c58578fbf241320436c6e0c",
            "glog-pfp-ruleFileCode/v1": "d42ee2aee074bd9274ccd3d08e7d620fa345b7c23d07ebfc5c7418898b1b7613"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "d42ee2aee074bd9274ccd3d08e7d620fa345b7c23d07ebfc5c7418898b1b7613"
          },
          "properties": {}
        },
        {
          "ruleId": "29ee34b7-ccf0-30dd-b66b-6f7bc6735d1b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Vulnerability in Transaction Block without Error Handling using Try/Catch and TROLLBACK\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 226,
                  "startColumn": 3,
                  "endLine": 232,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  tstart\n  kill ^PersonD(id)\n  kill ^PersonI(\"Name\", last, first, id)\n  kill ^PersonI(\"Phone\", phone)\n  kill ^PersonI(\"DOB\", intdob, id)\n  set $bit(^PersonI(\"Bitmap-ID\", chunk), position) = 0\n  tcommit"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "524a8872c2c71713c7d233796ce2436aa88e403eae222244eba769be399d226c",
            "glog-pfp-ruleFileCode/v1": "6d4ad56227d20f25898055bfda0ca64e27ba177955c1efc72131748ef0ad1950"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "6d4ad56227d20f25898055bfda0ca64e27ba177955c1efc72131748ef0ad1950"
          },
          "properties": {}
        },
        {
          "ruleId": "20132af7-7e3c-31be-bd4f-af6dee00c8e0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 228,
                  "startColumn": 1,
                  "endLine": 228,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonI(\"Name\", last, first, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "39ccfa5bfee025a32458dd23f11fa0fbde5a5e84975962b13a6dc5c3c7935ff7",
            "glog-pfp-ruleFileCode/v1": "9cc9bcc620932ba42597e1a6210b9aa47ad40853372fda4cf8a57843ca87c6d3"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9cc9bcc620932ba42597e1a6210b9aa47ad40853372fda4cf8a57843ca87c6d3"
          },
          "properties": {}
        },
        {
          "ruleId": "72d80781-e079-3971-b3e2-6b71b145a3f1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 227,
                  "startColumn": 1,
                  "endLine": 227,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonD(id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ba0fc87304c8cfdd7a5ae46bbd6732cb705590a374a0af6c559ee98fd900fc06",
            "glog-pfp-ruleFileCode/v1": "fbfa074c25598a93d276a65d1cd8f7625c3162ef0859e7ae8e56ed97364861dd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "fbfa074c25598a93d276a65d1cd8f7625c3162ef0859e7ae8e56ed97364861dd"
          },
          "properties": {}
        },
        {
          "ruleId": "1c63cc4b-0cc5-3298-8eb0-523a47135950",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 230,
                  "startColumn": 1,
                  "endLine": 230,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonI(\"DOB\", intdob, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ae317b0b2529d136a98727ca20c860a5f69130866ce7764ab51296235befc3f1",
            "glog-pfp-ruleFileCode/v1": "72280b74bd40d6c1b6730110938a1ed6931199110b9f9e2b968194cfea2c44ce"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "72280b74bd40d6c1b6730110938a1ed6931199110b9f9e2b968194cfea2c44ce"
          },
          "properties": {}
        },
        {
          "ruleId": "80e5bcc0-bd1f-325f-881b-f661c4d44193",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 229,
                  "startColumn": 1,
                  "endLine": 229,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  kill ^PersonI(\"Phone\", phone)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f6bce1cae137605db71abc33ba5171de8773f03c266f9ae5b8b2571cc8f993c6",
            "glog-pfp-ruleFileCode/v1": "8c64b374d9bba1d82fb6a3e95720ba33c7ba16252397344301bf24bc84a6d6e1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8c64b374d9bba1d82fb6a3e95720ba33c7ba16252397344301bf24bc84a6d6e1"
          },
          "properties": {}
        },
        {
          "ruleId": "1796d0d6-cb26-353c-bf29-b10f6a8320b8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Unprotected Transaction Block Vulnerability with Error Handling via Try/Catch and TROLLBACK\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 310,
                  "startColumn": 3,
                  "endLine": 327,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  tstart\n  set ^PersonD(id) = newanswers\n  if (newname '= currentname) {\n    // kill old name and add new name to index\n    kill ^PersonI(\"Name\", currentlast, currentfirst, id)\n    set ^PersonI(\"Name\", newlast, newfirst, id) = \"\"\n  }\n  if (newphone '= currentphone) {\n    // kill old phone and add new phone to index\n    kill ^PersonI(\"Phone\", currentphone)\n    set ^PersonI(\"Phone\", newphone) = id\n  }\n  if (newintdob '= currentintdob) {\n    // kill old dob and add new dob to index\n    kill ^PersonI(\"DOB\", currentintdob, id)\n    set ^PersonI(\"DOB\", newintdob, id) = \"\"\n  }\n  tcommit  // commit the transaction"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "eea00ea157f2529b3bbabc4f5e20dc33d25f70cf3ead49ab062e1d7158728039",
            "glog-pfp-ruleFileCode/v1": "7d97a0da241969d8b6bc1b8ef7d29dc93357400c5eebe15494f8c5338fd2ade8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7d97a0da241969d8b6bc1b8ef7d29dc93357400c5eebe15494f8c5338fd2ade8"
          },
          "properties": {}
        },
        {
          "ruleId": "8ce05a7d-fb70-3819-9558-f376f862e78e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 314,
                  "startColumn": 1,
                  "endLine": 314,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    kill ^PersonI(\"Name\", currentlast, currentfirst, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "549252a2a90c1958ff803d2a3c54e0e499f769457676cd390c226e4576cd765e",
            "glog-pfp-ruleFileCode/v1": "c2e3657171377b6ae29f818e99747196ae676817b036847bda59fb29f8bc456b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c2e3657171377b6ae29f818e99747196ae676817b036847bda59fb29f8bc456b"
          },
          "properties": {}
        },
        {
          "ruleId": "5a8eaf42-0bfb-34db-9b94-e596fca1725d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 319,
                  "startColumn": 1,
                  "endLine": 319,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    kill ^PersonI(\"Phone\", currentphone)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "811ecacde85f4a18d3a70ef32bdb6c98ef22c90eafe44b1a2361d821cbcfed55",
            "glog-pfp-ruleFileCode/v1": "08d790c5f05b94539a31cab33d359f9a0a2e5984fb4fc75e29a9a8a43d1419eb"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "08d790c5f05b94539a31cab33d359f9a0a2e5984fb4fc75e29a9a8a43d1419eb"
          },
          "properties": {}
        },
        {
          "ruleId": "33f20dda-eb54-3410-96f5-2d82070864bf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Authorization Verification and Referential/Index Consistency Maintenance in Global Node Deletion\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/Lookup3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 1,
                  "endLine": 324,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    kill ^PersonI(\"DOB\", currentintdob, id)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "080f2e69363b80969258314e19cf7dcee5d1c69c12150f348c143c8f7601d902",
            "glog-pfp-ruleFileCode/v1": "0418632810a07515c059cac234c6be7ec2cb747aae142d87bf017991cf6a047f"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0418632810a07515c059cac234c6be7ec2cb747aae142d87bf017991cf6a047f"
          },
          "properties": {}
        },
        {
          "ruleId": "54211a2f-95e9-3e07-897e-253a1bd9dc64",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ lacks length limit and downstream validation: Consider #maxlen for enhanced security.\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry4.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 3,
                  "endLine": 23,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"Phone (617): \", phone\n  } While '..ValidPhone(.phone)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2224ea682cca3496a5065321a9b213e3b1c825283f2c495757f70f950307605b",
            "glog-pfp-ruleFileCode/v1": "0526502925ea06aca6d1dfb2d861bdb9d35e6a60becfaf6287af14ebcb3c3c6e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0526502925ea06aca6d1dfb2d861bdb9d35e6a60becfaf6287af14ebcb3c3c6e"
          },
          "properties": {}
        },
        {
          "ruleId": "a812b057-eba4-3975-85d0-6cb81435013b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"READ Lacks Length Limit and Requires Downstream Validation: Consider Implementing #maxlen for Enhanced Security\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ObjectScript/DataEntry3.cls",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 3,
                  "endLine": 22,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  do {\n    read !, \"Phone (617): \", phone\n  } while '..ValidPhone(.phone)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "aa241c83c46100896efcf086be922b16a9d5bbf34ebe222e5e7231ccd43bcf56",
            "glog-pfp-ruleFileCode/v1": "17f42aea76a5e604c169425e393560120a0b62ef05cdf5447627310284e761c3"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "17f42aea76a5e604c169425e393560120a0b62ef05cdf5447627310284e761c3"
          },
          "properties": {}
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}